{"version":3,"sources":["../../src/Serie/index.ts","../../src/Serie/createSeries.ts","../../src/ClosedCircuitBuffer.ts","../../src/createSampler.ts","../../src/helpers.ts","../../src/Aggregator.ts","../../src/FieldGroups.ts","Demo2-LoadUnsampledHF.tsx/setup.ts","Demo2-LoadUnsampledHF.tsx/createSampler.ts","MultiTrackTableRenderer.tsx","Demo2-LoadUnsampledHF.tsx/index.tsx","App.tsx","index.tsx"],"names":["fnMin","serie","availLength","limit","Math","v","track","field","idx","offset","fnMax","fnMean","sum","cnt","fnCustom","callback","fnStDev","mean","sumOfSq","val","attachAggregateFn","Error","fn","options","n","Serie","this","attachCustomAggregateFn","getOffsetAdjAvailableLength","array","counter","createSerie","createSeries","ccb","keys","series","key","seriesHandler","get","target","ex","prop","Proxy","increment","advance","nextTime","preload","time","normallySkippedMax","missingSamples","elapsed","i","insertedTime","Object","prevSlot","fillMissingSamples","ClosedCircuitBuffer","tags","cursor","lastPeriodTime","serieInstances","arrayLike","length","Array","sampler","sampleTime","data","_preload","capture","_capture","lifo","absOffset","requestedLmt","offsetAdjLmt","pos","index","relative","ordinal","j","fifo","arrlen","lmt","getIndex","parseField","fieldDict","value","getFields","publicKeys","hiddenKeys","expressionKeys","ffills","hidden","cumulative","fill","fields","d","parseFieldsAsArray","parseFieldsAsDictionary","expressions","expr","createSampleFactory","sample","__count","fnOrValue","params","createSampler","addExpression","name","expression","initSeries","blank","bufferLength","collect","aggregateSample","currSlot","calculateExpressions","createSample","cumulatives","expressionDict","ffill","getSampleTime","interval","newSamplePredicate","suppressAutoSampling","timeKey","trackKeys","tracks","k","object","obj","keysToDelete","deleteKeys","t","result","defaultValue","Aggregator","sampling","getTracks","kv","filter","startSampling","_instance","setInterval","stopSampling","clearInterval","loaded","getOrCreateTrack","onLoad","trackKey","pk","valueOrDefault","onTrackStart","INPUT_INTERVAL","round","random","FIELDS","price","pv","qty","exch","TRACK_KEYS","EXPRESSIONS","rndWalk","RandomWalk","exchanges","split","_events","undefined","onIntervalData","onTrackUpdate","input_buffer","output","columns","init","eventHandlers","assign","gator","Sampler","__","entries","forEach","push","onUpdate","onInterval","aggregator","buffer","Date","getTime","next","exchIndex","style","border","margin","padding","paddingBottom","textAlign","props","multiTrack","row","css","flexWrap","map","col","grow","table","cols","items","Demo","useState","setMultiTrack","useEffect","stitch","MultiTrackTableRenderer","tabs","demo2","keyForItem","elementForItem","ReactDOM","render","App","document","getElementById"],"mappings":"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","file":"static/js/main.5c3152fd.chunk.js","sourcesContent":["import ClosedCircuitBuffer from \"../ClosedCircuitBuffer\";\r\nimport { SerieOptions, AggregateFn1Def, AggregateFn1, CustomAggregateFnDef, CustomAggregateFn, CustomAggregateVoidCallback } from '../types';\r\n\r\nexport type CompetingValuePair = { current?: number, best?: number };\r\n\r\nconst fnMin: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const v: CompetingValuePair = {};\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        v.current = track.array[idx.index][field];\r\n        if (typeof v.current !== 'undefined') {\r\n            if (typeof v.best === 'undefined' || v.current < v.best) {\r\n                v.best = v.current;\r\n            }\r\n        }\r\n    }, offset||0, limit)\r\n    return v.best;\r\n}\r\n\r\nconst fnMax: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const v: CompetingValuePair = {};\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        v.current = track.array[idx.index][field];\r\n        if (typeof v.current !== 'undefined') {\r\n            if (typeof v.best === 'undefined' || v.current > v.best) {\r\n                v.best = v.current;\r\n            }\r\n        }\r\n    }, offset||0, limit);\r\n    return v.best;\r\n}\r\n\r\n\r\nconst fnSum: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    let sum = 0;\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        sum += track.array[idx.index][field];\r\n    }, offset||0, limit);\r\n    return sum;\r\n}\r\n\r\nconst fnMean: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    let sum = 0;\r\n    let cnt = 0;\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        sum += track.array[idx.index][field];\r\n        cnt++;\r\n    }, offset||0, limit);\r\n    if (cnt === 0) return undefined;\r\n    return sum / cnt;\r\n}\r\n\r\nconst fnCustom = (serie: Serie, options: SerieOptions, n: number, offset: number, callback: CustomAggregateVoidCallback) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        callback(idx, track.array[idx.index][field])\r\n    }, offset||0, limit);\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Uses Bessel's correction of bias.\r\n * @param {array} array \r\n */\r\n \r\nconst fnStDev: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const { track, field } = serie;\r\n    const mean = serie.mean(n, offset)!;\r\n    let sumOfSq = 0;\r\n    let cnt = 0;\r\n    serie.fn(n, offset||0, (pos, val) => {\r\n        sumOfSq += (val - mean) ** 2;\r\n        cnt++;\r\n    });\r\n    if (cnt === 0) return undefined;\r\n    return Math.sqrt(sumOfSq / cnt);\r\n}\r\n\r\nfunction attachAggregateFn(serie: Serie, options: SerieOptions, fn: AggregateFn1Def) {\r\n    return (n: number, offset = 0) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset);\r\n    };\r\n}\r\nfunction attachCustomAggregateFn(serie: Serie, options: SerieOptions, fn: CustomAggregateFnDef) {\r\n    return (n: number, offset = 0, callback: CustomAggregateVoidCallback) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset, callback);\r\n    };\r\n}\r\n\r\nexport default class Serie {\r\n    \r\n    fn:  CustomAggregateFn;\r\n    min: AggregateFn1;\r\n    max: AggregateFn1;\r\n\r\n    mean: AggregateFn1;\r\n    \r\n    stDev: AggregateFn1;\r\n\r\n    value: (offset?: number) => number | undefined;\r\n\r\n    track: ClosedCircuitBuffer;\r\n    field: string;\r\n\r\n    constructor(options: SerieOptions) {\r\n        this.track = options.track;\r\n        this.field = options.field;\r\n\r\n        this.min = attachAggregateFn(this, options, fnMin);\r\n        this.max = attachAggregateFn(this, options, fnMax);\r\n        this.mean = attachAggregateFn(this, options, fnMean);\r\n        this.fn  = attachCustomAggregateFn(this, options, fnCustom);\r\n        this.stDev = attachAggregateFn(this, options, fnStDev);\r\n\r\n        this.value = (offset = 0) => {\r\n            const availLength = this.getOffsetAdjAvailableLength(offset);\r\n            if (availLength === 0) return undefined;\r\n            return this.track.get(offset)[this.field];\r\n        }\r\n    }\r\n\r\n    getOffsetAdjAvailableLength(offset: number) {\r\n        return Math.max(0, Math.min(this.track.array.length, this.track.counter + 1) - Math.abs(offset));\r\n    }\r\n\r\n    get availableLength() {\r\n        return this.getOffsetAdjAvailableLength(0);\r\n    }\r\n    \r\n\r\n    static createSerie(field: string, track: ClosedCircuitBuffer) {\r\n        return new Serie({\r\n            field,\r\n            track,\r\n        });\r\n    }\r\n}","import Serie from \".\";\r\nimport ClosedCircuitBuffer from \"../ClosedCircuitBuffer\";\r\n\r\nexport default function createSeries(ccb: ClosedCircuitBuffer) {\r\n    const keys = [\r\n        ...ccb.sampler.fields.publicKeys,\r\n        ...ccb.sampler.fields.expressionKeys,\r\n    ];\r\n\r\n    ccb.serieInstances = {};\r\n    const series = {};\r\n\r\n    keys.forEach(key => {\r\n        series[key] = () => {\r\n            if (!ccb.serieInstances[key]) {\r\n                ccb.serieInstances[key] = Serie.createSerie(key, ccb);\r\n            }\r\n            return ccb.serieInstances[key];\r\n        }\r\n    })\r\n\r\n    const seriesHandler = {\r\n        get: (target, prop, receiver) => {\r\n            try {\r\n                return target[prop]();    \r\n            }\r\n            catch (ex) {\r\n                throw new Error(\"Tried to access a non-existent Serie: '\" + prop + \"'\");\r\n            }\r\n        }\r\n    };\r\n    \r\n    ccb.series = new Proxy(series, seriesHandler);\r\n}\r\n","import Serie from './Serie';\r\nimport createSeries from './Serie/createSeries';\r\nimport {\r\n    IteratorCallback,\r\n    IteratorPosition,\r\n    Sampler,\r\n    Dictionary,\r\n} from './types';\r\n\r\nfunction _preload(track: ClosedCircuitBuffer, data: any) {\r\n    const sampleTime = track.sampler.getSampleTime(data[track.sampler.timeKey]);\r\n\r\n    if (!track.lastPeriodTime) {\r\n        track.lastPeriodTime = sampleTime;\r\n    } \r\n    else if (track.sampler.newSamplePredicate(track.current, data, sampleTime, track.lastPeriodTime)) { // shouldAdvance?\r\n        if (!advance(track, sampleTime, true)) {\r\n            return false; // done\r\n        }     \r\n    }\r\n\r\n    track.sampler.collect(track, track.current, data, sampleTime);\r\n\r\n    return true;\r\n}\r\n\r\nfunction _capture(track: ClosedCircuitBuffer, data: any) {\r\n    \r\n    const sampleTime = track.sampler.getSampleTime(data[track.sampler.timeKey]);\r\n    let loadingComplete = false;\r\n\r\n    if (!track.lastPeriodTime) {\r\n        track.lastPeriodTime = sampleTime;\r\n    } \r\n    else if (track.sampler.newSamplePredicate(track.current, data, sampleTime, track.lastPeriodTime)) {\r\n        advance(track, sampleTime, false);     \r\n    }\r\n\r\n    track.sampler.collect(track, track.current, data, sampleTime);\r\n    \r\n    if (track.onUpdate) track.onUpdate();\r\n}\r\n\r\nfunction increment(track: ClosedCircuitBuffer) {\r\n    track.counter++;\r\n    track.cursor++;\r\n    if (track.cursor === track.array.length) {\r\n        track.cursor = 0;\r\n    }\r\n}\r\n\r\nexport function advance(track: ClosedCircuitBuffer, nextTime?: number, preload?: boolean) {\r\n    \r\n    if (preload && track.counter + 1 === track.length) return false;\r\n\r\n    const time = nextTime || track.current[track.sampler.timeKey];\r\n    \r\n    // if any samples were skipped, fill them before capturing\r\n    if (track.sampler.interval > 0) {\r\n        fillMissingSamples(track, time);\r\n    }\r\n\r\n    increment(track);\r\n    \r\n    Object.assign(track.array[track.cursor], track.sampler.blank);\r\n    track.array[track.cursor][track.sampler.timeKey] = time;\r\n    track.lastPeriodTime = time;\r\n\r\n    return true;\r\n}\r\n\r\nfunction fillMissingSamples(track: ClosedCircuitBuffer, time: number) {\r\n\r\n    // when loading from history, we need to account for missing data\r\n    // and insert missing samples, something that would normally\r\n    // be taken care of by the timer\r\n\r\n    let normallySkippedMax = 1;\r\n    if (track.sampler.suppressAutoSampling) {\r\n        normallySkippedMax = 0;\r\n    }\r\n\r\n    if (track.sampler.interval > 0 && track.lastPeriodTime) {\r\n        const elapsed = time - track.lastPeriodTime;\r\n        const missingSamples = elapsed / track.sampler.interval - normallySkippedMax;\r\n        if (missingSamples > 0) {\r\n            for (let i = 0; i<missingSamples; i++) {\r\n\r\n                const insertedTime = track.lastPeriodTime + track.sampler.interval;\r\n\r\n                increment(track);\r\n\r\n                Object.assign(track.array[track.cursor], track.sampler.blank);\r\n                track.array[track.cursor][track.sampler.timeKey] = insertedTime;\r\n                \r\n                const prevSlot = track.get(-1);\r\n                track.sampler.ffill(track.array[track.cursor], prevSlot);                          \r\n                \r\n                track.lastPeriodTime = insertedTime;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass ClosedCircuitBuffer {\r\n    key: string = '';\r\n    tags: any = {};\r\n    array: any[] = [];\r\n    cursor: number = 0;\r\n    counter = 0;\r\n    lastPeriodTime: number = 0;\r\n    sampler: Sampler;\r\n    serieInstances: any = {};\r\n    series: Dictionary<Serie> = {};\r\n    onUpdate?: () => void;\r\n\r\n    constructor(length: number, sampler: Sampler) {\r\n        const arrayLike = { length }; \r\n        this.sampler = sampler!;\r\n        this.array = Array.from(arrayLike).map(this.sampler.createSample);\r\n        this.cursor = length ? 0 : -1;\r\n        createSeries(this);\r\n    }\r\n\r\n    /** \r\n      * Preload buffer with data\r\n      * @param data \r\n      * */\r\n    preload(data: any) {\r\n        return _preload(this, data);\r\n    }\r\n\r\n    /**\r\n     * Record real-time data from a stream\r\n     * @param data \r\n     */\r\n    capture(data: any) {\r\n        _capture(this, data);\r\n    }\r\n    \r\n    lifo(callback: IteratorCallback, offset: number, limit = -1) {\r\n        const absOffset     = Math.abs(offset || 0);\r\n        const requestedLmt  = limit >= 0 ? Math.abs(limit) : 0;\r\n        const offsetAdjLmt  = this.array.length - absOffset;\r\n        const pos: IteratorPosition = {\r\n            index: this.cursor - absOffset, // starting position (adjusted for offset)\r\n            relative: 0,                    \r\n            ordinal: 0,                     // zero based iteration number\r\n        };\r\n        let j   = this.array.length;\r\n        while (j--) {\r\n            if (absOffset  && pos.ordinal >= offsetAdjLmt) break;\r\n            if (limit >= 0 && pos.ordinal >= requestedLmt) break;\r\n            // loop around\r\n            if (pos.index < 0) pos.index = this.array.length - 1; \r\n            callback(pos, this.array);\r\n            pos.ordinal++;\r\n            pos.index--;\r\n            pos.relative--;\r\n        }\r\n    }\r\n\r\n    fifo(callback: IteratorCallback, limit = -1) {\r\n        const arrlen = this.array.length;\r\n        let lmt = limit >= 0 ? limit : arrlen;\r\n        const pos: IteratorPosition = {\r\n            index: 0,                   \r\n            relative: -(arrlen - 1),                    \r\n            ordinal: 0,                 \r\n        };\r\n        let j = arrlen;\r\n        let i = 0;\r\n        while (j-- && lmt--) {\r\n            pos.index = (arrlen + this.cursor - j) % arrlen;\r\n            callback(pos, this.array);\r\n            pos.ordinal++;\r\n            pos.relative++;\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n\r\n    get length() {\r\n        return this.array.length;\r\n    }\r\n\r\n    get current() {\r\n        return this.array[this.cursor];\r\n    }\r\n\r\n    get(offset = 0) {\r\n        return this.array[this.getIndex(offset)];\r\n    }\r\n\r\n    getIndex(offset = 0) {\r\n        let index = this.cursor + offset\r\n        if (offset > 0) {\r\n            return index  % this.array.length;\r\n        }\r\n        while (index < 0) {\r\n            index = this.array.length + index;\r\n        }\r\n        return index;\r\n    }\r\n}\r\n\r\nexport default ClosedCircuitBuffer;\r\n\r\n","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\nimport Serie from \"./Serie\";\r\nimport createSeries from \"./Serie/createSeries\";\r\nimport { Sampler, SamplerOptions, FieldDict, Expression, SampleFieldDictEntry, SampleFieldArrayItem, ForwardFillFunction } from \"./types\";\r\n\r\nfunction deleteKeys(object: any, keysToDelete: string[]) {\r\n    const obj: any = {...object};\r\n    keysToDelete.forEach(key => delete obj[key]);\r\n    return obj;\r\n}\r\n\r\nfunction parseField(fieldDict: FieldDict, key: string, value: any) {\r\n\r\n    fieldDict.keys.push(key);\r\n    \r\n    // hidden\r\n    if (key[0] === '_' && key[1] !== '_') {\r\n        fieldDict.hidden[key] = true;\r\n        fieldDict.hiddenKeys.push(key);\r\n    } else {\r\n        fieldDict.publicKeys.push(key);\r\n    }\r\n\r\n    if (typeof value === 'function') {\r\n        fieldDict.fn[key] = value;\r\n    } \r\n    else if (typeof value === 'object') {\r\n        if (!!value.cumulative) {\r\n            fieldDict.cumulative[key] = true;\r\n        }\r\n        fieldDict.fn[key] = value.fn;\r\n        fieldDict.fill[key] = value.fill;\r\n    } \r\n    else { // number\r\n        fieldDict.fn[key] = () => value;\r\n    }\r\n}\r\n\r\nfunction parseFieldsAsArray(fieldDict: FieldDict, options: SamplerOptions) {\r\n    const fields = options.fields as SampleFieldArrayItem[];\r\n    fields.forEach(field => {\r\n        switch (typeof field) {\r\n            case 'string':\r\n                parseField(fieldDict, field, d => d[field] )\r\n                break;\r\n            default: // must be of type SampleFieldNamed\r\n                parseField(fieldDict, field.name, field)\r\n                break;\r\n        }\r\n    });\r\n}\r\n\r\nfunction parseFieldsAsDictionary(fieldDict: FieldDict, options: SamplerOptions) {\r\n    Object.entries(options.fields).forEach(([key, value]) => {\r\n        parseField(fieldDict, key, value);\r\n    });\r\n}\r\n\r\nfunction getFields(options: SamplerOptions, expressions: any[]) {\r\n    const fieldDict: FieldDict = {\r\n        keys: [],\r\n        publicKeys: [],\r\n        hiddenKeys: [],\r\n        expressionKeys: [],\r\n        ffills: [],\r\n        hidden: {},\r\n        cumulative: {},\r\n        fn: {},\r\n        fill: {},\r\n    };\r\n\r\n    if (Array.isArray(options.fields)) {\r\n        parseFieldsAsArray(fieldDict, options);\r\n    } else {\r\n        parseFieldsAsDictionary(fieldDict, options);\r\n    }\r\n\r\n    expressions.forEach((expr: any) => {\r\n        fieldDict.expressionKeys.push(expr.name);\r\n    });\r\n\r\n    return fieldDict;\r\n}\r\n\r\nfunction createSampleFactory(fields: FieldDict) {\r\n    const sample = { __count: 0 };\r\n    fields.publicKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    fields.expressionKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    return () => ({ ...sample });\r\n}\r\n\r\nconst fnOrValue = (value: any, ...params: any[]) => {\r\n    if (typeof value === 'function') return value(...params);\r\n    return value;\r\n}\r\n\r\nexport function createSampler(options: SamplerOptions) {\r\n\r\n    const fields = getFields(options, []);\r\n\r\n    const sampler: Sampler = {\r\n        addExpression,          // hoisted funciton\r\n        blank:                  {},\r\n        bufferLength:           options.bufferLength,\r\n        collect,                // hoisted funciton\r\n        createSample:           createSampleFactory(fields),\r\n        cumulatives:            [],\r\n        expressionDict:         {},\r\n        expressions:            [],\r\n        ffill,                  // hoisted funciton\r\n        fields,\r\n        getSampleTime,          // hoisted funciton\r\n        interval:               options.interval || 0,\r\n        newSamplePredicate,     // hoisted funciton\r\n        series:                 {},\r\n        suppressAutoSampling:   options.suppressAutoSampling,\r\n        timeKey:                fnOrValue(options.timeKey)  || 'time',\r\n        trackKeys:              options.trackKeys || [],\r\n        tracks:                 [],\r\n    };\r\n\r\n    const initSeries = () => {\r\n        sampler.fields          = getFields(options, sampler.expressions);\r\n        sampler.createSample    = createSampleFactory(sampler.fields);\r\n        sampler.cumulatives     = sampler.fields.keys.filter(k => sampler.fields.cumulative[k]);\r\n\r\n        const sample            = sampler.createSample();\r\n        sampler.blank           = deleteKeys(sample, sampler.cumulatives);\r\n        sampler.tracks.forEach(t => createSeries(t));\r\n\r\n        sampler.fields.ffills   = sampler.fields.publicKeys\r\n                                    .filter(key => !!sampler.fields.fill[key])\r\n                                    .map(key => ({ key, fn: sampler.fields.fill[key] }) );\r\n    }\r\n\r\n    function getSampleTime(time: number) {\r\n        if (sampler.interval) return time - (time % sampler.interval); \r\n        return time;\r\n    }\r\n\r\n    function calculateExpressions(currSlot: any, track: ClosedCircuitBuffer) {\r\n        sampler.expressions.forEach(expr => {\r\n            const result = expr.expression(track.series);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[expr.name] = result;\r\n            }\r\n        })\r\n    }\r\n\r\n    function aggregateSample(currSlot: any, data: any, time: number) {\r\n        currSlot.__count++;\r\n        sampler.fields.hiddenKeys.forEach(key => {\r\n            sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n        });\r\n        sampler.fields.publicKeys.forEach(key => {\r\n            if (key === sampler.timeKey) {\r\n                if (!currSlot[sampler.timeKey]) {\r\n                    currSlot[sampler.timeKey] = getSampleTime(data[key]);\r\n                }\r\n            } \r\n            else {\r\n                const result = sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n                if (typeof result !== 'undefined') {\r\n                    currSlot[key] = result;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    function ffill(currSlot: any, prevSlot: any) {\r\n        currSlot[sampler.timeKey] = prevSlot[sampler.timeKey] + sampler.interval;\r\n        sampler.fields.ffills.forEach(ffill => {\r\n            currSlot[ffill.key] = ffill.fn(currSlot, prevSlot[ffill.key]);\r\n        })\r\n        currSlot.__count = -1;\r\n    };\r\n\r\n    function collect(track: ClosedCircuitBuffer, currSlot: any, data: any, time: number) {     \r\n        aggregateSample(currSlot, data, time);\r\n        calculateExpressions(currSlot, track);\r\n        return true;\r\n    };\r\n    \r\n    function newSamplePredicate(currSlot: any, data: any, time: number, lastPeriodTime: number) {\r\n        // compare elapsed time since last period time\r\n        if (sampler.interval === 0) return true;\r\n        if (time - lastPeriodTime >= sampler.interval) return true; \r\n        return false;\r\n    };\r\n    \r\n    function addExpression(name: string, expression: Expression) {\r\n        if (sampler.expressionDict[name]) throw new Error(`A field with the name '${name}' already exists.`)\r\n        sampler.expressionDict[name] = expression;\r\n        sampler.expressions.push({ name, expression });\r\n        initSeries();\r\n        \r\n    }\r\n\r\n    initSeries();\r\n\r\n    return sampler;\r\n}\r\n\r\n\r\n    \r\n","import { ConditionalOp } from \"./types\";\r\n\r\nexport function value(value: any, defaultValue: any) {\r\n    return typeof value !== 'undefined' ? value : defaultValue;\r\n}\r\n\r\nexport function when(condition: boolean, value: number | undefined | ConditionalOp) {\r\n    if (condition) {\r\n        if (typeof value === 'function') {\r\n            return value();\r\n        }\r\n        return value;\r\n    }\r\n    return undefined;\r\n}\r\n","import ClosedCircuitBuffer, { advance } from \"./ClosedCircuitBuffer\";\r\nimport { BufferFilter, Expression, Sampler, SamplerOptions, Dictionary } from './types';\r\nimport { createSampler } from './createSampler';\r\nimport { value as valueOrDefault } from './helpers';\r\n\r\nconst noFilter = () => true;\r\n\r\nclass Aggregator {  \r\n\r\n  timer:          any;\r\n  sampler:        Sampler;\r\n  tracks:         Dictionary<ClosedCircuitBuffer> = {};\r\n  sampling:       boolean         = false;\r\n  \r\n  // -- EVENTS \r\n  onTrackStart?:  (track: ClosedCircuitBuffer) => void;\r\n  onInterval?:    () => void;\r\n  onLoad?:        () => void;\r\n  \r\n  constructor(options: SamplerOptions) {\r\n    this.sampler = createSampler(options);\r\n  }\r\n\r\n  addExpression(name: string, expression: Expression) {\r\n    this.sampler.addExpression(name, expression);\r\n  }\r\n\r\n  getTracks(filter?: BufferFilter) {\r\n    return Object.entries(this.tracks)\r\n      .filter(kv => (filter || (() => true))(kv[0], kv[1]))\r\n      .map(kv => kv[1]);\r\n  }\r\n  \r\n  startSampling() {\r\n    if (this.sampler.suppressAutoSampling) return;\r\n    if (this.sampling) return;\r\n    const _instance = this;\r\n    // timer for buffer group\r\n    this.timer = setInterval(() => {\r\n      _instance.sampler.tracks.forEach((_track) => {\r\n        advance(_track);\r\n      })\r\n      _instance.onInterval && _instance.onInterval();\r\n    }, this.sampler.interval);\r\n    this.sampling = true;\r\n  }\r\n\r\n  stopSampling() {\r\n    clearInterval(this.timer);\r\n    this.sampling = false;\r\n  }\r\n\r\n  preload(data: any) {\r\n    const track = this.getOrCreateTrack(data);\r\n    const loaded = track.preload(data);\r\n    if (!loaded) this.onLoad && this.onLoad();\r\n    return loaded;\r\n  }\r\n\r\n  capture(data: any, filter?: BufferFilter) {\r\n    const track = this.getOrCreateTrack(data);\r\n    track.capture(data);\r\n  }\r\n\r\n  getOrCreateTrack(data: any) {\r\n    const sampler = this.sampler;\r\n    const trackKey = sampler.trackKeys.map(pk => valueOrDefault(data[pk], '')).join('.');\r\n    if (!this.tracks[trackKey]) {\r\n        const track = new ClosedCircuitBuffer(sampler.bufferLength, sampler);\r\n        sampler.trackKeys.forEach(pk => track.tags[pk] = data[pk]);\r\n        track.key = trackKey;\r\n        this.tracks[trackKey] = track;\r\n        sampler.tracks.push(track);\r\n        this.onTrackStart && this.onTrackStart(track);\r\n    }\r\n    return this.tracks[trackKey];\r\n  }\r\n}\r\n\r\nexport default Aggregator;\r\n","\r\nimport { value, when } from './helpers';\r\nimport { SampleFields } from './types';\r\n\r\nconst { min, max, abs } = Math;\r\n\r\nconst time = {\r\n    dataFields: [ 'time' ],\r\n    fields: {\r\n        time:           (d, curr) => value(curr, d.time), \r\n    } as SampleFields,\r\n};\r\n\r\nconst ohlc = {\r\n    dataFields: [ 'price'],\r\n    fields: {\r\n        open:           { fn: (d, curr) => value(curr, d.price), fill: p => p.close }, \r\n        high:           { fn: (d, curr) => max(d.price, value(curr, d.price)), fill: p => p.close }, \r\n        low:            { fn: (d, curr) => min(d.price, value(curr, d.price)), fill: p => p.close },\r\n        close:          { fn: (d) => d.price, fill: p => p.close },\r\n    } as SampleFields,\r\n};\r\n\r\nconst side = {\r\n    dataFields: [ 'buy', 'sell' ],\r\n    fields: {\r\n        // Underscore fields are special:\r\n        // - they are run first\r\n        // - they do not get added to sample (hidden)\r\n        // - they perform some operation \r\n        //   e.g. here they set a value on the data object itself\r\n        _buy:           (d) => when(d.qty > 0, () => d.buy  = 1),\r\n        _sell:          (d) => when(d.qty < 0, () => d.sell = 1),\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nconst volume = {\r\n    dataFields: [ 'qty' ],\r\n    fields: {\r\n        // volume\r\n        buyVol:         { fn: (d, curr) => when(d.buy, value(curr, 0) + d.qty), fill: () => 0 },\r\n        sellVol:        { fn: (d, curr) => when(d.sell, value(curr, 0) + d.qty), fill: () => 0 },\r\n        ttlVol:         { fn: (d, curr) => value(curr, 0) + abs(d.qty), fill: () => 0 },\r\n        netVol:         { fn: (d, curr) => value(curr, 0) + d.qty, fill: () => 0 },\r\n        cumNetVol:      { \r\n                            fn: (d, curr) => value(curr, 0) + d.qty, \r\n                            cumulative: true \r\n                        },\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nconst mv = {\r\n    dataFields: [ 'buy', 'sell', 'price', 'qty', 'ttlMv', 'ttlVol' ],\r\n    fields: {\r\n        // mv\r\n        buyMv:          { fn: (d, curr) => when(d.buy, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n        sellMv:         { fn: (d, curr) => when(d.sell, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n        ttlMv:          { fn: (d, curr) => value(curr, 0) + d.price * abs(d.qty), fill: () => 0 },\r\n        netMv:          { fn: (d, curr) => value(curr, 0) + d.price * d.qty, fill: () => 0 },\r\n\r\n        // volume weighted\r\n        volWtdPrice:    { fn: (d, curr, acc) => acc.ttlMv / acc.ttlVol, fill: () => 0 },\r\n    } as SampleFields,\r\n};\r\n\r\nconst stats = {\r\n    dataFields: [ 'buy', 'sell' ],\r\n    fields: {\r\n        // counts\r\n        ttlTradeCount:  { fn: (d, curr) => value(curr, 0) + 1, fill: () => 0 },\r\n        buyTradeCount:  { fn: (d, curr) => when(d.buy, value(curr, 0) + 1), fill: () => 0 },\r\n        sellTradeCount: { fn: (d, curr) => when(d.sell, value(curr, 0) + 1), fill: () => 0 },\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nexport default {\r\n    cryptoTrade: {\r\n        time,\r\n        ohlc,    \r\n        side,\r\n        volume,\r\n        mv,\r\n        stats,\r\n    },\r\n};\r\n\r\n    \r\n","import Aggregator from \"sample-gator\";\r\nimport RandomWalk from '@reactiff/random-walk';\r\nimport { fnOrValue } from \"@reactiff/ui-core\";\r\n\r\nexport const INPUT_INTERVAL   = () => Math.round(Math.random() * 1000); // ms\r\nexport const OUTPUT_INTERVAL  = 1000; // ms\r\nexport const LENGTH           = 15;\r\n\r\nexport const FIELDS: any = {\r\n  time:   { fn: (d: any) => d.time },\r\n  price:  { fn: (d: any) => d.price,  fill: (d: any, pv: any) => pv },\r\n  qty:    { fn: (d: any) => d.qty,    fill: (d: any, pv: any) => pv },\r\n  exch:   { fn: (d: any) => d.exch,   fill: (d: any, pv: any) => pv },\r\n};\r\n\r\nexport const TRACK_KEYS = [\"exch\"];\r\nexport const EXPRESSIONS = {};\r\n// {\r\n//   sma3: (series: any) => series.price.mean(3),\r\n//   sma5: (series: any) => series.price.mean(5),\r\n//   sma8: (series: any) => series.price.mean(8),\r\n//   sma10: (series: any) => series.price.mean(10),\r\n//   ema10: (series: any) => {\r\n//     const n = 10;\r\n//     const key = `ema${n}`;\r\n//     const price = series.price;\r\n//     const calcSerie = series[key];\r\n//     if (calcSerie.availableLength < n + 1) return undefined;\r\n//     let prev = calcSerie.value(-1);\r\n//     if (!prev) prev = price.mean(n, -1);\r\n//     const k = 2 / (n + 1);\r\n//     const ema = price.value() * k + prev * (1 - k);\r\n//     return ema;\r\n//   },\r\n//   cross: (_: any) => {\r\n//     // check cross to the up side\r\n//     if (_.ema10.value( 0) > _.sma10.value( 0) && _.ema10.value(-1) < _.sma10.value(-1)) return 1\r\n//     // check cross to the down side\r\n//     if (_.ema10.value( 0) < _.sma10.value( 0) && _.ema10.value(-1) > _.sma10.value(-1)) return -1;\r\n//     return undefined;\r\n//   }\r\n// }; \r\n\r\n// DATA LOADING AND SIMULATION\r\n\r\nexport const SAMPLING_ENABLED   = false;\r\n\r\nconst rndWalk                   = new RandomWalk(1, 1000, 500, 10, 10);\r\n\r\n// DATA PRELOADING\r\nexport const PRELOADING_ENABLED = true;\r\nconst exchanges = 'A1'.split(',');\r\n\r\nexport const PRELOAD            = (aggregator: Aggregator, buffer: any) => {\r\n\r\n  buffer.time = new Date().getTime()\r\n\r\n  do {\r\n    buffer.time                 += fnOrValue(INPUT_INTERVAL);\r\n    buffer.price                = rndWalk.next();\r\n    buffer.qty                  = Math.round(Math.random() * 100 - 50)\r\n    \r\n    const exchIndex = Math.round(Math.random() * (exchanges.length - 1));\r\n    const exch = exchanges[exchIndex];\r\n\r\n    buffer.exch                 = exch;\r\n\r\n\r\n  } while (aggregator.preload(buffer));\r\n  \r\n   \r\n}\r\n\r\n// DATA SIMULATION\r\n\r\nconst SIM_FIXED_INTERVAL        = 200;\r\nconst SIM_RANDOM_INTERVAL       = false;\r\nconst SIM_MIN_INTERVAL          = 20;\r\nconst SIM_MAX_INTERVAL          = 1500;\r\n\r\n\r\nexport const SIMULATION_ENABLED = false;\r\nexport const SIMULATE           = (aggregator: Aggregator, input_buffer: any) => {\r\n    \r\n    input_buffer.time           = new Date().getTime();\r\n    input_buffer.price          = rndWalk.next();\r\n    input_buffer.qty            = Math.round(Math.random() * 100 - 50);\r\n\r\n    const exch                  = exchanges[0] // exchanges[Math.round(Math.random())];\r\n    input_buffer.exch           = exch;\r\n\r\n    aggregator.capture(input_buffer);\r\n    \r\n    let interval                = SIM_FIXED_INTERVAL;\r\n\r\n    if (SIM_RANDOM_INTERVAL) {\r\n      interval = Math.random() * (SIM_MAX_INTERVAL - SIM_MIN_INTERVAL) + SIM_MIN_INTERVAL;\r\n    }\r\n\r\n    setTimeout((s, b) => {\r\n      SIMULATE(s, b)\r\n    }, interval, aggregator, input_buffer );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","import Sampler, { ClosedCircuitBuffer } from \"sample-gator\";\r\nimport * as __ from \"./setup\";\r\nexport type TrackDataDictionary = { [index: string]: any[] };\r\nexport type SamplerEventHandlers = {\r\n  onLoad?: () => void;\r\n  onIntervalData?: () => void;\r\n  onTrackUpdate?: (track: ClosedCircuitBuffer) => void;\r\n};\r\n\r\nconst _events: SamplerEventHandlers = {\r\n  onLoad:         undefined,\r\n  onIntervalData: undefined,\r\n  onTrackUpdate:  undefined,\r\n};\r\n\r\nconst input_buffer: any = {};\r\nexport const output: TrackDataDictionary = {};\r\nexport const columns: TrackDataDictionary = {};\r\nexport const tracks: ClosedCircuitBuffer[] = [];\r\n\r\nconst init = (eventHandlers: SamplerEventHandlers) => {\r\n  Object.assign(_events, eventHandlers);\r\n\r\n  const gator = new Sampler({\r\n    interval: __.OUTPUT_INTERVAL,\r\n    bufferLength: __.LENGTH,\r\n    trackKeys: __.TRACK_KEYS,\r\n    fields: __.FIELDS,\r\n  });\r\n\r\n  // init INPUT placeholder\r\n  const blank = gator.sampler.createSample();\r\n  Object.assign(input_buffer, blank);\r\n  Object.entries(__.EXPRESSIONS).forEach(([key, fn]: any[]) => gator.addExpression(key, fn));\r\n\r\n  gator.onTrackStart = (track) => {\r\n    output[track.key] = new Array(__.LENGTH);\r\n    tracks.push(track);\r\n    columns[track.key] = Object.keys(track.series);\r\n    track.onUpdate = () => {\r\n      _events.onTrackUpdate && _events.onTrackUpdate(track);\r\n    };\r\n  };\r\n\r\n  gator.onInterval  = () => _events.onIntervalData && _events.onIntervalData();\r\n  gator.onLoad      = () => _events.onLoad && _events.onLoad();\r\n\r\n  if (__.PRELOADING_ENABLED) {\r\n    __.PRELOAD(gator, input_buffer);\r\n    _events.onIntervalData && _events.onIntervalData();\r\n  }\r\n\r\n  if (__.SAMPLING_ENABLED) gator.startSampling();\r\n  if (__.SIMULATION_ENABLED) __.SIMULATE(gator, input_buffer);\r\n};\r\n\r\nexport default init;\r\n","import React from \"react\";\r\nimport ui from '@reactiff/ui-core';\r\n\r\nconst style = {\r\n  border: 'thin solid white',\r\n  margin: 0,\r\n  padding: 8,\r\n  '& table tr td': {\r\n    paddingBottom: 8,\r\n  },\r\n  '& table tr td:first-of-type': {\r\n    textAlign: 'left',\r\n  }\r\n};\r\n\r\nexport default (props: { data: any }) => {\r\n  \r\n  const multiTrack = props.data;\r\n  const keys = Object.keys(multiTrack);\r\n\r\n  \r\n\r\n  return <ui.row css={{flexWrap: 'wrap'}}>\r\n    {\r\n      keys.map((key, index) => {\r\n        const track = multiTrack[key];\r\n        return <ui.col key={key} css={style} grow>\r\n          <ui.table \r\n            cols={[...track.columns]} \r\n            items={track.array} \r\n          />\r\n        </ui.col>\r\n      })\r\n    }\r\n  </ui.row>\r\n}\r\n","import React, { useEffect, useState } from \"react\";\r\nimport createSampler, { tracks, columns } from './createSampler';\r\nimport MultiTrackTableRenderer from \"../MultiTrackTableRenderer\";\r\n\r\nconst Demo = () => {\r\n\r\n  const [multiTrack, setMultiTrack] = useState<any>();\r\n\r\n  // Init sampler\r\n  useEffect(() => {\r\n\r\n    const stitch = () => {\r\n      const data = {};\r\n      tracks.forEach(track => {\r\n        const items = new Array(track.length);\r\n        track.fifo((pos, buffer) => {\r\n          items[pos.ordinal] = buffer[pos.index];\r\n        });\r\n        data[track.key] = { array: items, columns: columns[track.key] };\r\n      });\r\n      setMultiTrack(data);\r\n    }\r\n\r\n    \r\n    createSampler({ \r\n      // when preload completes\r\n      onLoad: () => stitch(),\r\n      // every time a new interval sample is created\r\n      onIntervalData: () => {},\r\n      // whenever any track is updated\r\n      onTrackUpdate: () => stitch(),\r\n    })\r\n  \r\n  }, []);\r\n\r\n  if (!multiTrack) return null;\r\n  return <MultiTrackTableRenderer data={multiTrack} /> \r\n}\r\n\r\nexport default Demo;","import React from \"react\";\r\n\r\nimport ui from '@reactiff/ui-core';\r\n\r\n// import Demo1 from './Demo1-LoadSampledData.tsx';\r\nimport Demo2 from './Demo2-LoadUnsampledHF.tsx';\r\n\r\n// import Demo3 from './Demo1-LoadSampledData.tsx';\r\n// import Demo4 from './Demo1-LoadSampledData.tsx';\r\n\r\nexport default () => {\r\n\r\n\r\n  const tabs = {\r\n\r\n    // demo1: <><h2>Demo 1 - Load pre-sampeld data</h2> <Demo1 /></>,\r\n    demo2: <><h2>Demo 2 - Load unsampled HF data</h2><Demo2 /></>\r\n\r\n  };\r\n\r\n  const keys = Object.keys(tabs);\r\n\r\n  return <ui.tabs items={keys} keyForItem={key => key} elementForItem={(key) => tabs[key]} />\r\n}\r\n\r\n\r\n  \r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\nimport './css/index.css'\r\nimport './css/orthogonal.css'\r\nimport './css/flex.css'\r\n\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n"],"sourceRoot":""}