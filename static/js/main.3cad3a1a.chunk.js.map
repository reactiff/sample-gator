{"version":3,"sources":["../../src/Serie/index.ts","../../src/ClosedCircuitBuffer.ts","../../src/createSampler.ts","../../src/helpers.ts","../../src/Sampler.ts","../../src/FieldGroups.ts","Demo2-LoadUnsampledHF.tsx/setup.ts","Demo2-LoadUnsampledHF.tsx/createSampler.ts","MultiTrackTableRenderer.tsx","Demo2-LoadUnsampledHF.tsx/index.tsx","App.tsx","index.tsx"],"names":["fnMin","serie","availLength","limit","Math","v","track","field","idx","offset","fnMax","fnMean","sum","cnt","fnCustom","callback","fnStDev","mean","sumOfSq","val","attachAggregateFn","Error","fn","options","n","Serie","this","attachCustomAggregateFn","createSerie","getOffsetAdjAvailableLength","ClosedCircuitBuffer","key","tags","array","cursor","counter","lastPeriodTime","serieInstances","series","arrayLike","length","Array","sampler","get","getIndex","index","createSeries","keys","fields","_instance","seriesHandler","target","prop","Proxy","nextSample","currentTime","current","__count","prevSlot","Object","fillMissingSamples","normallySkippedMax","interval","missingSamples","time","elapsed","i","insertedTime","preload","sampleTime","getSampleTime","data","shouldAdvance","capture","captureTime","lifo","absOffset","requestedLmt","offsetAdjLmt","pos","relative","ordinal","j","fifo","arrlen","lmt","parseField","fieldDict","value","getFields","publicKeys","hiddenKeys","expressionKeys","ffills","hidden","cumulative","fill","d","parseFieldsAsArray","parseFieldsAsDictionary","expressions","expr","createSampleFactory","sample","fnOrValue","params","createSampler","addExpression","name","expression","initSeries","blank","bufferLength","collect","currSlot","result","aggregateSample","calculateExpressions","createSample","cumulatives","expressionDict","ffill","newSamplePredicate","suppressAutoSampling","timeKey","trackKeys","tracks","k","object","obj","keysToDelete","deleteKeys","t","defaultValue","MultiTrackBuffer","sampling","getTracks","kv","filter","startSampling","setInterval","_track","stopSampling","clearInterval","getOrCreateTrack","trackKey","pk","valueOrDefault","onTrackStart","FIELDS","price","pv","qty","exch","TRACK_KEYS","EXPRESSIONS","sma3","sma5","sma8","sma10","ema10","calcSerie","availableLength","prev","cross","_","date","Date","rndWalk","RandomWalk","exchanges","_events","onIntervalData","undefined","onTrackUpdate","input_buffer","output","columns","init","eventHandlers","assign","gator","Sampler","__","entries","map","push","onUpdate","onInterval","buffer","st","getTime","rm","LENGTH","next","round","random","SIMULATE","setTimeout","s","b","props","multiTrack","row","table","cols","items","Demo","useState","setMultiTrack","useEffect","forEach","MultiTrackTableRenderer","tabs","demo2","keyForItem","elementForItem","ReactDOM","render","App","document","getElementById"],"mappings":"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","file":"static/js/main.3cad3a1a.chunk.js","sourcesContent":["import ClosedCircuitBuffer from \"../ClosedCircuitBuffer\";\r\nimport { SerieOptions, AggregateFn1Def, AggregateFn1, CustomAggregateFnDef, CustomAggregateFn, CustomAggregateVoidCallback } from '../types';\r\n\r\nexport type CompetingValuePair = { current?: number, best?: number };\r\n\r\nconst fnMin: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const v: CompetingValuePair = {};\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        v.current = track.array[idx.index][field];\r\n        if (typeof v.current !== 'undefined') {\r\n            if (typeof v.best === 'undefined' || v.current < v.best) {\r\n                v.best = v.current;\r\n            }\r\n        }\r\n    }, offset||0, limit)\r\n    return v.best;\r\n}\r\n\r\nconst fnMax: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const v: CompetingValuePair = {};\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        v.current = track.array[idx.index][field];\r\n        if (typeof v.current !== 'undefined') {\r\n            if (typeof v.best === 'undefined' || v.current > v.best) {\r\n                v.best = v.current;\r\n            }\r\n        }\r\n    }, offset||0, limit);\r\n    return v.best;\r\n}\r\n\r\n\r\nconst fnSum: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    let sum = 0;\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        sum += track.array[idx.index][field];\r\n    }, offset||0, limit);\r\n    return sum;\r\n}\r\n\r\nconst fnMean: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    let sum = 0;\r\n    let cnt = 0;\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        sum += track.array[idx.index][field];\r\n        cnt++;\r\n    }, offset||0, limit);\r\n    if (cnt === 0) return undefined;\r\n    return sum / cnt;\r\n}\r\n\r\nconst fnCustom = (serie: Serie, options: SerieOptions, n: number, offset: number, callback: CustomAggregateVoidCallback) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        callback(idx, track.array[idx.index][field])\r\n    }, offset||0, limit);\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Uses Bessel's correction of bias.\r\n * @param {array} array \r\n */\r\n \r\nconst fnStDev: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const { track, field } = serie;\r\n    const mean = serie.mean(n, offset)!;\r\n    let sumOfSq = 0;\r\n    let cnt = 0;\r\n    serie.fn(n, offset||0, (pos, val) => {\r\n        sumOfSq += (val - mean) ** 2;\r\n        cnt++;\r\n    });\r\n    if (cnt === 0) return undefined;\r\n    return Math.sqrt(sumOfSq / cnt);\r\n}\r\n\r\nfunction attachAggregateFn(serie: Serie, options: SerieOptions, fn: AggregateFn1Def) {\r\n    return (n: number, offset = 0) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset);\r\n    };\r\n}\r\nfunction attachCustomAggregateFn(serie: Serie, options: SerieOptions, fn: CustomAggregateFnDef) {\r\n    return (n: number, offset = 0, callback: CustomAggregateVoidCallback) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset, callback);\r\n    };\r\n}\r\n\r\nexport default class Serie {\r\n    \r\n    fn:  CustomAggregateFn;\r\n    min: AggregateFn1;\r\n    max: AggregateFn1;\r\n\r\n    mean: AggregateFn1;\r\n    \r\n    stDev: AggregateFn1;\r\n\r\n    value: (offset?: number) => number | undefined;\r\n\r\n    track: ClosedCircuitBuffer;\r\n    field: string;\r\n\r\n    constructor(options: SerieOptions) {\r\n        this.track = options.track;\r\n        this.field = options.field;\r\n\r\n        this.min = attachAggregateFn(this, options, fnMin);\r\n        this.max = attachAggregateFn(this, options, fnMax);\r\n        this.mean = attachAggregateFn(this, options, fnMean);\r\n        this.fn  = attachCustomAggregateFn(this, options, fnCustom);\r\n        this.stDev = attachAggregateFn(this, options, fnStDev);\r\n\r\n        this.value = (offset = 0) => {\r\n            const availLength = this.track.getOffsetAdjAvailableLength(offset);\r\n            if (availLength === 0) return undefined;\r\n            return this.track.get(offset)[this.field];\r\n        }\r\n    }\r\n\r\n    get availableLength() {\r\n        const availLength = this.track.getOffsetAdjAvailableLength(0);\r\n        return availLength;\r\n    }\r\n    \r\n\r\n    static createSerie(field: string, track: ClosedCircuitBuffer) {\r\n        return new Serie({\r\n            field,\r\n            track,\r\n        });\r\n    }\r\n}","import Serie from './Serie';\r\nimport {\r\n    IteratorCallback,\r\n    IteratorPosition,\r\n    NewSamplePredicate,\r\n    Sampler,\r\n    Dictionary,\r\n} from './types';\r\n\r\nclass ClosedCircuitBuffer {\r\n    \r\n    key: string = '';\r\n    tags: any = {};\r\n\r\n    array: any[] = [];\r\n    cursor: number = 0;\r\n    counter = 0;\r\n\r\n    shouldAdvance: NewSamplePredicate;\r\n\r\n    // prevSample: any;\r\n    lastPeriodTime: number = 0;\r\n    sampler: Sampler;\r\n\r\n    onUpdate?: () => void;\r\n    lastAdvanceTime?: number;\r\n\r\n    serieInstances: any = {};\r\n    series: Dictionary<Serie> = {};\r\n\r\n    constructor(length: number, sampler: Sampler) {\r\n        const arrayLike = { length }; \r\n        this.sampler = sampler!;\r\n        this.array = Array.from(arrayLike).map(this.sampler.createSample);\r\n        this.cursor = length ? 0 : -1;\r\n        this.shouldAdvance = this.sampler.newSamplePredicate;\r\n        this.createSeries();\r\n    }\r\n    \r\n    getOffsetAdjAvailableLength(offset: number) {\r\n        return Math.max(\r\n            0,\r\n            Math.min(this.array.length, this.counter + 1) - Math.abs(offset)\r\n        );\r\n    }\r\n\r\n    get length() {\r\n        return this.array.length;\r\n    }\r\n\r\n    get current() {\r\n        return this.array[this.cursor];\r\n    }\r\n\r\n    get(offset = 0) {\r\n        return this.array[this.getIndex(offset)];\r\n    }\r\n\r\n    getIndex(offset = 0) {\r\n        let index = this.cursor + offset\r\n        if (offset > 0) {\r\n            return index  % this.array.length;\r\n        }\r\n        while (index < 0) {\r\n            index = this.array.length + index;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    createSeries() {\r\n        const keys = [\r\n            ...this.sampler.fields.publicKeys,\r\n            ...this.sampler.fields.expressionKeys,\r\n        ];\r\n\r\n        this.serieInstances = {};\r\n        const series = {};\r\n\r\n        const _instance = this;\r\n        keys.forEach(key => {\r\n            series[key] = () => {\r\n                if (!_instance.serieInstances[key]) {\r\n                    _instance.serieInstances[key] = Serie.createSerie(key, _instance);\r\n                }\r\n                return _instance.serieInstances[key];\r\n            }\r\n        })\r\n\r\n        const seriesHandler = {\r\n            get: (target, prop, receiver) => {\r\n                try {\r\n                    return target[prop]();    \r\n                }\r\n                catch(ex) {\r\n                    throw new Error(\"Tried to access a non-existent Serie: '\" + prop + \"'\");\r\n                }\r\n            }\r\n        };\r\n        \r\n        this.series = new Proxy(series, seriesHandler);\r\n    }\r\n    \r\n    nextSample(caller: string) {\r\n        \r\n        const currentTime = this.current[this.sampler.timeKey];\r\n        this.lastAdvanceTime = currentTime;\r\n\r\n        // see if the current slot hasn't received any data and fill forward from last slot\r\n        if (this.current.__count === 0) {    \r\n            const prevSlot = this.get(-1);\r\n            if (prevSlot.__count) {\r\n                this.sampler.ffill(this.current, prevSlot);                          \r\n            }\r\n        }  \r\n\r\n        this.counter++;\r\n        this.cursor++;\r\n        if (this.cursor === this.array.length) {\r\n            this.cursor = 0;\r\n        }\r\n        \r\n        Object.assign(this.array[this.cursor], this.sampler.blank);\r\n\r\n        this.array[this.cursor][this.sampler.timeKey] = currentTime + this.sampler.interval;\r\n    };\r\n\r\n    fillMissingSamples(time: number) {\r\n        // when loading from history, we need to account for missing data\r\n        // and insert missing samples, something that would normally\r\n        // be taken care of by the timer\r\n\r\n        let normallySkippedMax = 1;\r\n        if (this.sampler.suppressAutoSampling) {\r\n            normallySkippedMax = 0;\r\n        }\r\n\r\n        if (this.sampler.interval > 0 && this.lastPeriodTime) {\r\n            const elapsed = time - this.lastPeriodTime;\r\n            const missingSamples = elapsed / this.sampler.interval - normallySkippedMax;\r\n            if (missingSamples > 0) {\r\n                for (let i = 0; i<missingSamples; i++) {\r\n                    const offset = this.sampler.interval;\r\n                    const insertedTime = this.lastPeriodTime + offset;\r\n                    this.nextSample('fillMissingSamples');\r\n                    this.lastPeriodTime = insertedTime;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Preload buffer with history data\r\n     * @param data \r\n     */\r\n    preload(data: any) {\r\n\r\n        const sampleTime = this.sampler.getSampleTime(data.time);\r\n        \r\n        this.fillMissingSamples(sampleTime)\r\n\r\n        this.sampler.collect(this, this.current, data, sampleTime);\r\n        \r\n        if (this.shouldAdvance(this.current, data, sampleTime, this.lastPeriodTime)) {\r\n            this.nextSample('preload'); \r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Record real-time data from a stream\r\n     * @param data \r\n     * @returns \r\n     */\r\n    capture(data: any, time?: number) {\r\n        const captureTime = time || data[this.sampler.timeKey];\r\n        const sampleTime = this.sampler.getSampleTime(captureTime);\r\n\r\n        if (!this.lastPeriodTime) {\r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n        // if any samples were skipped, fill them before capturing\r\n        if (this.sampler.interval > 0 && this.sampler.suppressAutoSampling) {\r\n            this.fillMissingSamples(sampleTime);\r\n        }\r\n\r\n        if (data.exch !== this.key) {\r\n            debugger;\r\n        }\r\n\r\n        this.sampler.collect(this, this.current, data, sampleTime);\r\n\r\n        // if (data.exch !== this.key) {\r\n        //     debugger;\r\n        // }\r\n\r\n        if (this.sampler.interval === 0) {\r\n            this.nextSample('capture'); \r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n        \r\n        if (data.exch !== this.key) {\r\n            debugger;\r\n        }\r\n\r\n        this.onUpdate && this.onUpdate();\r\n\r\n        if (data.exch !== this.key) {\r\n            debugger;\r\n        }\r\n\r\n    }\r\n    \r\n    lifo(callback: IteratorCallback, offset: number, limit = -1) {\r\n        const absOffset     = Math.abs(offset || 0);\r\n        const requestedLmt  = limit >= 0 ? Math.abs(limit) : 0;\r\n        const offsetAdjLmt  = this.array.length - absOffset;\r\n        \r\n        const pos: IteratorPosition = {\r\n            index: this.cursor - absOffset, // starting position (adjusted for offset)\r\n            relative: 0,                    \r\n            ordinal: 0,                     // zero based iteration number\r\n        };\r\n\r\n        let j   = this.array.length;\r\n        while (j--) {\r\n\r\n            if (absOffset  && pos.ordinal >= offsetAdjLmt) {\r\n                break;\r\n            }\r\n            if (limit >= 0 && pos.ordinal >= requestedLmt) {\r\n                break;\r\n            }\r\n\r\n            // loop around\r\n            if (pos.index < 0) {\r\n                pos.index = this.array.length - 1; \r\n            }\r\n\r\n            callback(\r\n                pos,\r\n                this.array\r\n            );\r\n\r\n            pos.ordinal++;\r\n            pos.index--;\r\n            pos.relative--;\r\n        }\r\n    }\r\n\r\n    fifo(callback: IteratorCallback, limit = -1) {\r\n        const arrlen = this.array.length;\r\n        let lmt = limit >= 0 ? limit : arrlen;\r\n\r\n        const pos: IteratorPosition = {\r\n            index: 0,                   \r\n            relative: -(arrlen - 1),                    \r\n            ordinal: 0,                 \r\n        };\r\n\r\n        let j = arrlen;\r\n        let i = 0;\r\n        while (j-- && lmt--) {\r\n            pos.index = (arrlen + this.cursor - j) % arrlen;\r\n\r\n            callback(\r\n                pos,\r\n                this.array\r\n            );\r\n\r\n            pos.ordinal++;\r\n            pos.relative++;\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n}\r\n\r\nexport default ClosedCircuitBuffer;","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\n\r\nimport Serie from \"./Serie\";\r\nimport { Sampler, SamplerOptions, FieldDict, Expression, SampleFieldDictEntry, SampleFieldArrayItem, ForwardFillFunction } from \"./types\";\r\n\r\nfunction deleteKeys(object: any, keysToDelete: string[]) {\r\n    const obj: any = {...object};\r\n    keysToDelete.forEach(key => delete obj[key]);\r\n    return obj;\r\n}\r\n\r\nfunction parseField(fieldDict: FieldDict, key: string, value: any) {\r\n\r\n    fieldDict.keys.push(key);\r\n    \r\n    // hidden\r\n    if (key[0] === '_' && key[1] !== '_') {\r\n        fieldDict.hidden[key] = true;\r\n        fieldDict.hiddenKeys.push(key);\r\n    } else {\r\n        fieldDict.publicKeys.push(key);\r\n    }\r\n\r\n    if (typeof value === 'function') {\r\n        fieldDict.fn[key] = value;\r\n    } \r\n    else if (typeof value === 'object') {\r\n        if (!!value.cumulative) {\r\n            fieldDict.cumulative[key] = true;\r\n        }\r\n        fieldDict.fn[key] = value.fn;\r\n        fieldDict.fill[key] = value.fill;\r\n    } \r\n    else { // number\r\n        fieldDict.fn[key] = () => value;\r\n    }\r\n}\r\n\r\nfunction parseFieldsAsArray(fieldDict: FieldDict, options: SamplerOptions) {\r\n    const fields = options.fields as SampleFieldArrayItem[];\r\n    fields.forEach(field => {\r\n        switch (typeof field) {\r\n            case 'string':\r\n                parseField(fieldDict, field, d => d[field] )\r\n                break;\r\n            default: // must be of type SampleFieldNamed\r\n                parseField(fieldDict, field.name, field)\r\n                break;\r\n        }\r\n    });\r\n}\r\n\r\nfunction parseFieldsAsDictionary(fieldDict: FieldDict, options: SamplerOptions) {\r\n    Object.entries(options.fields).forEach(([key, value]) => {\r\n        parseField(fieldDict, key, value);\r\n    });\r\n}\r\n\r\nfunction getFields(options: SamplerOptions, expressions: any[]) {\r\n    const fieldDict: FieldDict = {\r\n        keys: [],\r\n        publicKeys: [],\r\n        hiddenKeys: [],\r\n        expressionKeys: [],\r\n        ffills: [],\r\n        hidden: {},\r\n        cumulative: {},\r\n        fn: {},\r\n        fill: {},\r\n    };\r\n\r\n    if (Array.isArray(options.fields)) {\r\n        parseFieldsAsArray(fieldDict, options);\r\n    } else {\r\n        parseFieldsAsDictionary(fieldDict, options);\r\n    }\r\n\r\n    expressions.forEach((expr: any) => {\r\n        fieldDict.expressionKeys.push(expr.name);\r\n    });\r\n\r\n    return fieldDict;\r\n}\r\n\r\nfunction createSampleFactory(fields: FieldDict) {\r\n    const sample = { __count: 0 };\r\n    fields.publicKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    fields.expressionKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    return () => ({ ...sample });\r\n}\r\n\r\nconst fnOrValue = (value: any, ...params: any[]) => {\r\n    if (typeof value === 'function') return value(...params);\r\n    return value;\r\n}\r\n\r\nexport function createSampler(options: SamplerOptions) {\r\n\r\n    const fields = getFields(options, []);\r\n\r\n    const sampler: Sampler = {\r\n        addExpression,          // hoisted funciton\r\n        blank:                  {},\r\n        bufferLength:           options.bufferLength,\r\n        collect,                // hoisted funciton\r\n        createSample:           createSampleFactory(fields),\r\n        cumulatives:            [],\r\n        expressionDict:         {},\r\n        expressions:            [],\r\n        ffill,                  // hoisted funciton\r\n        fields,\r\n        getSampleTime,          // hoisted funciton\r\n        interval:               options.interval || 0,\r\n        newSamplePredicate,     // hoisted funciton\r\n        series:                 {},\r\n        suppressAutoSampling:   options.suppressAutoSampling,\r\n        timeKey:                fnOrValue(options.timeKey)  || 'time',\r\n        trackKeys:              options.trackKeys || [],\r\n        tracks:                 [],\r\n    };\r\n\r\n    const initSeries = () => {\r\n        sampler.fields          = getFields(options, sampler.expressions);\r\n        sampler.createSample    = createSampleFactory(sampler.fields);\r\n        sampler.cumulatives     = sampler.fields.keys.filter(k => sampler.fields.cumulative[k]);\r\n\r\n        const sample            = sampler.createSample();\r\n        sampler.blank           = deleteKeys(sample, sampler.cumulatives);\r\n        sampler.tracks.forEach(t => t.createSeries());\r\n\r\n        sampler.fields.ffills   = sampler.fields.publicKeys\r\n                                    .filter(key => !!sampler.fields.fill[key])\r\n                                    .map(key => ({ key, fn: sampler.fields.fill[key] }) );\r\n    }\r\n\r\n    function getSampleTime(time: number) {\r\n        if (sampler.interval) return time - (time % sampler.interval); \r\n        return time;\r\n    }\r\n\r\n    function calculateExpressions(currSlot: any, track: ClosedCircuitBuffer) {\r\n        sampler.expressions.forEach(expr => {\r\n            const result = expr.expression(track.series);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[expr.name] = result;\r\n            }\r\n        })\r\n    }\r\n\r\n    function aggregateSample(currSlot: any, data: any, time: number) {\r\n        currSlot.__count++;\r\n        sampler.fields.hiddenKeys.forEach(key => {\r\n            sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n        });\r\n        sampler.fields.publicKeys.forEach(key => {\r\n            if (key === sampler.timeKey) {\r\n                const origTime = time || data[key];\r\n                const sampleTime = getSampleTime(origTime);\r\n                data[key] = sampleTime\r\n            }\r\n            const result = sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[key] = result;\r\n            }\r\n        });\r\n    }\r\n\r\n    function ffill(currSlot: any, prevSlot: any) {\r\n        currSlot[sampler.timeKey] = prevSlot[sampler.timeKey] + sampler.interval;\r\n        sampler.fields.ffills.forEach(ffill => {\r\n            currSlot[ffill.key] = ffill.fn(currSlot, prevSlot[ffill.key]);\r\n        })\r\n        currSlot.__count = 1;\r\n    };\r\n\r\n    function collect(track: ClosedCircuitBuffer, currSlot: any, data: any, time: number) {     \r\n        aggregateSample(currSlot, data, time);\r\n        calculateExpressions(currSlot, track);\r\n    };\r\n    \r\n    function newSamplePredicate(currSlot: any, data: any, time: number, lastPeriodTime: number) {\r\n        const sampleTime = getSampleTime(time);\r\n        // compare elapsed time since last period time\r\n        if (typeof lastPeriodTime === 'undefined') return true;\r\n        if (sampler.interval === 0) return true;\r\n        if (sampleTime - lastPeriodTime >= sampler.interval) return true; \r\n        return false;\r\n    };\r\n    \r\n    function addExpression(name: string, expression: Expression) {\r\n        if (sampler.expressionDict[name]) throw new Error(`A field with the name '${name}' already exists.`)\r\n        sampler.expressionDict[name] = expression;\r\n        sampler.expressions.push({ name, expression });\r\n        initSeries();\r\n        \r\n    }\r\n\r\n    initSeries();\r\n\r\n    return sampler;\r\n}\r\n\r\n\r\n    \r\n","import { ConditionalOp } from \"./types\";\r\n\r\nexport function value(value: any, defaultValue: any) {\r\n    return typeof value !== 'undefined' ? value : defaultValue;\r\n}\r\n\r\nexport function when(condition: boolean, value: number | undefined | ConditionalOp) {\r\n    if (condition) {\r\n        if (typeof value === 'function') {\r\n            return value();\r\n        }\r\n        return value;\r\n    }\r\n    return undefined;\r\n}\r\n","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\nimport { BufferFilter, Expression, Sampler, SamplerOptions, Dictionary } from './types';\r\nimport { createSampler } from './createSampler';\r\nimport { value as valueOrDefault } from './helpers';\r\n\r\nconst noFilter = () => true;\r\n\r\nclass MultiTrackBuffer {  \r\n\r\n  timer:          any;\r\n  sampler:        Sampler;\r\n  tracks:         Dictionary<ClosedCircuitBuffer> = {};\r\n  sampling:       boolean         = false;\r\n  \r\n  // -- EVENTS \r\n  onTrackStart?:  (track: ClosedCircuitBuffer) => void;\r\n  onInterval?:    () => void;\r\n  \r\n  constructor(options: SamplerOptions) {\r\n    this.sampler = createSampler(options);\r\n  }\r\n\r\n  addExpression(name: string, expression: Expression) {\r\n    this.sampler.addExpression(name, expression);\r\n  }\r\n\r\n  getTracks(filter?: BufferFilter) {\r\n    return Object.entries(this.tracks)\r\n      .filter(kv => (filter || (() => true))(kv[0], kv[1]))\r\n      .map(kv => kv[1]);\r\n  }\r\n  \r\n  startSampling() {\r\n    if (this.sampler.suppressAutoSampling) return;\r\n    if (this.sampling) return;\r\n    \r\n    const _instance = this;\r\n\r\n    // timer for buffer group\r\n    this.timer = setInterval(\r\n      () => {\r\n        _instance.sampler.tracks.forEach((_track) => {\r\n          _track.nextSample('timer')\r\n        })\r\n        if (_instance.onInterval) {\r\n          _instance.onInterval();\r\n        }\r\n      }, this.sampler.interval\r\n    );\r\n\r\n    this.sampling = true;\r\n  }\r\n\r\n  stopSampling() {\r\n    clearInterval(this.timer);\r\n    this.sampling = false;\r\n  }\r\n\r\n  preload(data: any) {\r\n    const track = this.getOrCreateTrack(data);\r\n    track.preload(data);\r\n  }\r\n\r\n  capture(data: any, filter?: BufferFilter) {\r\n    const track = this.getOrCreateTrack(data);\r\n    track.capture(data);\r\n  }\r\n\r\n  getOrCreateTrack(data: any) {\r\n    \r\n    const sampler = this.sampler;\r\n    \r\n    const trackKey = sampler.trackKeys.map(pk => \r\n      valueOrDefault(data[pk], '')\r\n    ).join('.');\r\n\r\n    if (!this.tracks[trackKey]) {\r\n        const track = new ClosedCircuitBuffer(sampler.bufferLength, sampler);\r\n        sampler.trackKeys.forEach(pk => {\r\n          track.tags[pk] = data[pk];\r\n        })\r\n        track.key = trackKey;\r\n        this.tracks[trackKey] = track;\r\n        sampler.tracks.push(track);\r\n        this.onTrackStart && this.onTrackStart(track);\r\n    }\r\n\r\n    return this.tracks[trackKey];\r\n  }\r\n}\r\n\r\nexport default MultiTrackBuffer;\r\n","\r\nimport { value, when } from './helpers';\r\nimport { SampleFields } from './types';\r\n\r\nconst { min, max, abs } = Math;\r\n\r\nconst time = {\r\n    dataFields: [ 'time' ],\r\n    fields: {\r\n        time:           (d, curr) => value(curr, d.time), \r\n    } as SampleFields,\r\n};\r\n\r\nconst ohlc = {\r\n    dataFields: [ 'price'],\r\n    fields: {\r\n        open:           { fn: (d, curr) => value(curr, d.price), fill: p => p.close }, \r\n        high:           { fn: (d, curr) => max(d.price, value(curr, d.price)), fill: p => p.close }, \r\n        low:            { fn: (d, curr) => min(d.price, value(curr, d.price)), fill: p => p.close },\r\n        close:          { fn: (d) => d.price, fill: p => p.close },\r\n    } as SampleFields,\r\n};\r\n\r\nconst side = {\r\n    dataFields: [ 'buy', 'sell' ],\r\n    fields: {\r\n        // Underscore fields are special:\r\n        // - they are run first\r\n        // - they do not get added to sample (hidden)\r\n        // - they perform some operation \r\n        //   e.g. here they set a value on the data object itself\r\n        _buy:           (d) => when(d.qty > 0, () => d.buy  = 1),\r\n        _sell:          (d) => when(d.qty < 0, () => d.sell = 1),\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nconst volume = {\r\n    dataFields: [ 'qty' ],\r\n    fields: {\r\n        // volume\r\n        buyVol:         { fn: (d, curr) => when(d.buy, value(curr, 0) + d.qty), fill: () => 0 },\r\n        sellVol:        { fn: (d, curr) => when(d.sell, value(curr, 0) + d.qty), fill: () => 0 },\r\n        ttlVol:         { fn: (d, curr) => value(curr, 0) + abs(d.qty), fill: () => 0 },\r\n        netVol:         { fn: (d, curr) => value(curr, 0) + d.qty, fill: () => 0 },\r\n        cumNetVol:      { \r\n                            fn: (d, curr) => value(curr, 0) + d.qty, \r\n                            cumulative: true \r\n                        },\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nconst mv = {\r\n    dataFields: [ 'buy', 'sell', 'price', 'qty', 'ttlMv', 'ttlVol' ],\r\n    fields: {\r\n        // mv\r\n        buyMv:          { fn: (d, curr) => when(d.buy, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n        sellMv:         { fn: (d, curr) => when(d.sell, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n        ttlMv:          { fn: (d, curr) => value(curr, 0) + d.price * abs(d.qty), fill: () => 0 },\r\n        netMv:          { fn: (d, curr) => value(curr, 0) + d.price * d.qty, fill: () => 0 },\r\n\r\n        // volume weighted\r\n        volWtdPrice:    { fn: (d, curr, acc) => acc.ttlMv / acc.ttlVol, fill: () => 0 },\r\n    } as SampleFields,\r\n};\r\n\r\nconst stats = {\r\n    dataFields: [ 'buy', 'sell' ],\r\n    fields: {\r\n        // counts\r\n        ttlTradeCount:  { fn: (d, curr) => value(curr, 0) + 1, fill: () => 0 },\r\n        buyTradeCount:  { fn: (d, curr) => when(d.buy, value(curr, 0) + 1), fill: () => 0 },\r\n        sellTradeCount: { fn: (d, curr) => when(d.sell, value(curr, 0) + 1), fill: () => 0 },\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nexport default {\r\n    cryptoTrade: {\r\n        time,\r\n        ohlc,    \r\n        side,\r\n        volume,\r\n        mv,\r\n        stats,\r\n    },\r\n};\r\n\r\n    \r\n","import Sampler from \"sample-gator\";\r\nimport RandomWalk from '@reactiff/random-walk';\r\n\r\nexport const INTERVAL = 1000; // ms\r\nexport const LENGTH = 20;\r\nexport const FIELDS: any = {\r\n  time:   { fn: (d: any) => d.time },\r\n  price:  { fn: (d: any) => d.price,  fill: (d: any, pv: any) => pv },\r\n  qty:    { fn: (d: any) => d.qty,    fill: (d: any, pv: any) => pv },\r\n  exch:   { fn: (d: any) => d.exch,   fill: (d: any, pv: any) => pv },\r\n};\r\n\r\nexport const TRACK_KEYS = [\"exch\"];\r\nexport const EXPRESSIONS = {\r\n  sma3: (series: any) => series.price.mean(3),\r\n  sma5: (series: any) => series.price.mean(5),\r\n  sma8: (series: any) => series.price.mean(8),\r\n  sma10: (series: any) => series.price.mean(10),\r\n  ema10: (series: any) => {\r\n    const n = 10;\r\n    const key = `ema${n}`;\r\n    const price = series.price;\r\n    const calcSerie = series[key];\r\n    if (calcSerie.availableLength < n + 1) return undefined;\r\n    let prev = calcSerie.value(-1);\r\n    if (!prev) prev = price.mean(n, -1);\r\n    const k = 2 / (n + 1);\r\n    const ema = price.value() * k + prev * (1 - k);\r\n    return ema;\r\n  },\r\n  cross: (_: any) => {\r\n    // check cross to the up side\r\n    if (_.ema10.value( 0) > _.sma10.value( 0) && _.ema10.value(-1) < _.sma10.value(-1)) return 1\r\n    // check cross to the down side\r\n    if (_.ema10.value( 0) < _.sma10.value( 0) && _.ema10.value(-1) > _.sma10.value(-1)) return -1;\r\n    return undefined;\r\n  }\r\n}; \r\n\r\n// DATA LOADING AND SIMULATION\r\n\r\nexport const SAMPLING_ENABLED   = true;\r\n\r\nconst date                      = new Date();\r\nconst rndWalk                   = new RandomWalk(1, 1000, 500, 10, 10);\r\n\r\n// DATA PRELOADING\r\nexport const PRELOADING_ENABLED = true;\r\nconst exchanges = ['A2'];\r\n\r\nexport const PRELOAD            = (sampler: Sampler, buffer: any) => {\r\n    \r\n    const st                    = date.getTime()\r\n    const rm                    = st % 1000\r\n\r\n    buffer.time                 = st - rm - 1000;\r\n\r\n    for (let i = 0; i < LENGTH - 1; i++) {\r\n\r\n        buffer.time             += 1000;\r\n        buffer.price            = rndWalk.next();\r\n        buffer.qty              = Math.round(Math.random() * 100 - 50);\r\n        buffer.exch             = exchanges[0] // exchanges[Math.round(Math.random())];\r\n\r\n        sampler.preload(buffer);\r\n    }\r\n}\r\n\r\n// DATA SIMULATION\r\n\r\nconst SIM_FIXED_INTERVAL        = 200;\r\nconst SIM_RANDOM_INTERVAL       = false;\r\nconst SIM_MIN_INTERVAL          = 20;\r\nconst SIM_MAX_INTERVAL          = 1500;\r\n\r\n\r\nexport const SIMULATION_ENABLED = true;\r\nexport const SIMULATE           = (sampler: Sampler, input_buffer: any) => {\r\n    \r\n    input_buffer.time           = new Date().getTime();\r\n    input_buffer.price          = rndWalk.next();\r\n    input_buffer.qty            = Math.round(Math.random() * 100 - 50);\r\n\r\n    const exch                  = exchanges[0] // exchanges[Math.round(Math.random())];\r\n    input_buffer.exch           = exch;\r\n\r\n    sampler.capture(input_buffer);\r\n    \r\n    let interval                = SIM_FIXED_INTERVAL;\r\n\r\n    if (SIM_RANDOM_INTERVAL) {\r\n      interval = Math.random() * (SIM_MAX_INTERVAL - SIM_MIN_INTERVAL) + SIM_MIN_INTERVAL;\r\n    }\r\n\r\n    setTimeout((s, b) => {\r\n      SIMULATE(s, b)\r\n    }, interval, sampler, input_buffer );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","import Sampler, { ClosedCircuitBuffer } from \"sample-gator\";\r\nimport * as __ from \"./setup\";\r\nexport type TrackDataDictionary = { [index: string]: any[] };\r\nexport type SamplerEventHandlers = {\r\n  onIntervalData?: () => void;\r\n  onTrackUpdate?: (track: ClosedCircuitBuffer) => void;\r\n};\r\n\r\nconst _events: SamplerEventHandlers = {\r\n  onIntervalData: undefined,\r\n  onTrackUpdate: undefined,\r\n};\r\n\r\nconst input_buffer: any = {};\r\nexport const output: TrackDataDictionary = {};\r\nexport const columns: TrackDataDictionary = {};\r\nexport const tracks: ClosedCircuitBuffer[] = [];\r\n\r\nconst init = (eventHandlers: SamplerEventHandlers) => {\r\n  Object.assign(_events, eventHandlers);\r\n\r\n  const gator = new Sampler({\r\n    interval: __.INTERVAL,\r\n    bufferLength: __.LENGTH,\r\n    trackKeys: __.TRACK_KEYS,\r\n    fields: __.FIELDS,\r\n  });\r\n\r\n  // init INPUT placeholder\r\n  const blank = gator.sampler.createSample();\r\n  Object.assign(input_buffer, blank);\r\n  Object.entries(__.EXPRESSIONS).map(([key, fn]: any[]) => gator.addExpression(key, fn));\r\n\r\n  gator.onTrackStart = (track) => {\r\n    output[track.key] = new Array(__.LENGTH);\r\n    tracks.push(track);\r\n    columns[track.key] = Object.keys(track.series);\r\n    track.onUpdate = () => {\r\n      _events.onTrackUpdate && _events.onTrackUpdate(track);\r\n    };\r\n  };\r\n\r\n  gator.onInterval = () => _events.onIntervalData && _events.onIntervalData();\r\n\r\n  if (__.PRELOADING_ENABLED) {\r\n    __.PRELOAD(gator, input_buffer);\r\n    _events.onIntervalData && _events.onIntervalData();\r\n  }\r\n\r\n  if (__.SAMPLING_ENABLED) gator.startSampling();\r\n  if (__.SIMULATION_ENABLED) __.SIMULATE(gator, input_buffer);\r\n};\r\n\r\nexport default init;\r\n","import React from \"react\";\r\nimport ui from '@reactiff/ui-core';\r\n\r\nexport default (props: { data: any }) => {\r\n\r\n  const multiTrack = props.data;\r\n  const keys = Object.keys(multiTrack);\r\n\r\n  return <ui.row>\r\n    {\r\n      keys.map((key, index) => {\r\n        return <ui.table \r\n          key={key}\r\n          cols={multiTrack[key].columns} \r\n          items={multiTrack[key].array} \r\n        />\r\n      })\r\n    }\r\n  </ui.row>\r\n}\r\n","import React, { useEffect, useState } from \"react\";\r\nimport createSampler, { tracks, columns } from './createSampler';\r\nimport MultiTrackTableRenderer from \"../MultiTrackTableRenderer\";\r\n\r\nconst Demo = () => {\r\n\r\n  const [multiTrack, setMultiTrack] = useState<any>();\r\n\r\n  // Init sampler\r\n  useEffect(() => {\r\n\r\n    createSampler({ \r\n      onTrackUpdate: () => {\r\n\r\n        const data = {};\r\n\r\n        tracks.forEach(track => {\r\n\r\n          const items = new Array(track.length);\r\n\r\n          track.fifo((pos, buffer) => {\r\n            items[pos.ordinal] = buffer[pos.index];\r\n          });\r\n\r\n          data[track.key] = { array: items, columns: columns[track.key] };\r\n\r\n        });\r\n\r\n        setMultiTrack(data);\r\n      }\r\n    })\r\n  \r\n  }, []);\r\n\r\n  if (!multiTrack) return null;\r\n  return <MultiTrackTableRenderer data={multiTrack} /> \r\n}\r\n\r\nexport default Demo;","import React from \"react\";\r\n\r\nimport ui from '@reactiff/ui-core';\r\n\r\nimport Demo1 from './Demo1-LoadSampledData.tsx';\r\nimport Demo2 from './Demo2-LoadUnsampledHF.tsx';\r\n\r\n// import Demo3 from './Demo1-LoadSampledData.tsx';\r\n// import Demo4 from './Demo1-LoadSampledData.tsx';\r\n\r\nexport default () => {\r\n\r\n\r\n  const tabs = {\r\n\r\n    // demo1: <><h2>Demo 1 - Load pre-sampeld data</h2> <Demo1 /></>,\r\n    demo2: <><h2>Demo 2 - Load unsampled HF data</h2><Demo2 /></>\r\n\r\n  };\r\n\r\n  const keys = Object.keys(tabs);\r\n\r\n  return <ui.tabs items={keys} keyForItem={key => key} elementForItem={(key) => tabs[key]} />\r\n}\r\n\r\n\r\n  \r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\nimport './css/index.css'\r\nimport './css/orthogonal.css'\r\nimport './css/flex.css'\r\n\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n"],"sourceRoot":""}