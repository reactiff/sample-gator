{"version":3,"sources":["DataTable/Header.tsx","DataTable/TableRow.tsx","DataTable/index.tsx","../../src/Serie/index.ts","../../src/ClosedCircuitBuffer.ts","../../src/createSampler.ts","../../src/helpers.ts","../../src/Sampler.ts","../../src/FieldGroups.ts","App.tsx","index.tsx"],"names":["Header","props","cols","map","c","index","key","TableRow","item","isArray","Array","className","value","toFixed","Table","items","cellPadding","cellSpacing","length","itemIndex","fnMin","serie","availLength","limit","Math","v","track","field","idx","offset","fnMax","fnMean","sum","cnt","fnCustom","callback","fnStDev","mean","sumOfSq","val","attachAggregateFn","Error","fn","options","n","Serie","this","attachCustomAggregateFn","createSerie","getOffsetAdjAvailableLength","ClosedCircuitBuffer","tags","array","cursor","counter","lastPeriodTime","serieInstances","series","arrayLike","sampler","get","getIndex","createSeries","keys","fields","_instance","Proxy","target","nextSample","currentTime","current","__count","prevSlot","Object","fillMissingSamples","normallySkippedMax","interval","missingSamples","time","elapsed","i","insertedTime","preload","sampleTime","getSampleTime","data","shouldAdvance","capture","captureTime","lifo","absOffset","requestedLmt","offsetAdjLmt","pos","relative","ordinal","j","fifo","arrlen","lmt","parseField","fieldDict","getFields","publicKeys","hiddenKeys","expressionKeys","hidden","cumulative","fill","d","parseFieldsAsArray","parseFieldsAsDictionary","expressions","expr","createSampleFactory","sample","fnOrValue","params","createSampler","addExpression","name","expression","k","object","obj","keysToDelete","deleteKeys","t","blank","bufferLength","collect","currSlot","result","aggregateSample","calculateExpressions","createSample","cumulatives","expressionDict","ffill","newSamplePredicate","suppressAutoSampling","timeKey","trackKeys","tracks","defaultValue","when","condition","noFilter","MultiTrackBuffer","sampling","getTracks","kv","filter","startSampling","setInterval","_track","stopSampling","clearInterval","createDataTracks","trackKey","pk","valueOrDefault","min","max","abs","cryptoTrade","dataFields","curr","ohlc","open","p","high","low","close","side","_buy","_sell","volume","buyVol","sellVol","ttlVol","netVol","cumNetVol","mv","buyMv","sellMv","ttlMv","netMv","volWtdPrice","acc","stats","ttlTradeCount","buyTradeCount","sellTradeCount","rndWalk","RandomWalk","buffer","Sampler","FieldGroups","price","calcSerie","availableLength","prev","_","ema10","sma10","capsule","exch","qty","m","React","useRef","clickIndex","periods","tickCount","initialized","stopped","useState","columns","setColumns","fifoData","setFifoData","readTrackData","useCallback","fifos","useEffect","onTrackStart","onUpdate","onInterval","values","delayCapture","next","round","random","simulateTradeEvent","Date","getTime","setTimeout","handleClick","onClick","style","marginBottom","DataTable","ReactDOM","render","App","document","getElementById"],"mappings":"gUAiBeA,EAfA,SAACC,GAEZ,IAAMC,EAAOD,EAAMC,MAAQ,GAE3B,OAAO,+BACH,4BAEQA,EAAKC,KAAI,SAACC,EAAQC,GACd,OAAO,wBAAIC,IAAKD,GAAQD,SC6B7BG,EArCE,SAACN,GAEd,IAAMO,EAAOP,EAAMO,KACbN,EAAOD,EAAMC,KAEbO,EAAUC,MAAMD,QAAQD,GAE9B,OACI,wBAAIG,UAAU,oBAGNF,GACAD,EAAKL,KAAI,SAACS,EAAYP,GAClB,OAAO,wBAAIC,IAAKJ,EAAKG,IAEI,kBAAVO,GACPA,EAAMC,QAAQ,QAOzBJ,GACDP,EAAKC,KAAI,SAACC,EAAQC,GACd,OAAO,wBAAIC,IAAKJ,EAAKG,IAEM,kBAAZG,EAAKJ,IACZI,EAAKJ,GAAGS,QAAQ,SCQ7BC,G,MA5BD,SAACb,GAEX,IAAMC,EAAiBD,EAAMC,KACvBa,EAAQd,EAAMc,MAEpB,OAAKA,EAIE,2BAAOC,YAAa,EAAGC,YAAa,EAAGN,UAAU,cAGhDT,GACAA,EAAKgB,OAAS,GACd,kBAAC,EAAD,CAAQhB,KAAMA,IAGlB,+BAEQa,EAAMZ,KAAI,SAACK,EAAWW,GAAZ,OACN,kBAAC,EAAD,CAAUb,IAAKa,EAAWX,KAAMA,EAAMN,KAAMA,SAfzC,O,8aCVvB,IAAMkB,EAAyB,SAACC,EAAD,OAC3B,IAAMC,EAAcD,mBAApB,EACME,EAAQC,WAAd,GACMC,EAAN,GACQC,EAAiBL,EAAzB,MAAeM,EAAUN,EAAzB,MASA,OARAK,QAAW,SAAAE,GACPH,UAAYC,QAAYE,EAAZF,OAAZD,GACA,qBAAWA,EAAP,UACI,qBAAOA,EAAP,MAAiCA,UAAYA,EAAjD,QACIA,OAASA,EAATA,WAGTI,GAPHH,KAQOD,EAAP,MAGEK,EAAyB,SAACT,EAAD,OAC3B,IAAMC,EAAcD,mBAApB,EACME,EAAQC,WAAd,GACMC,EAAN,GACQC,EAAiBL,EAAzB,MAAeM,EAAUN,EAAzB,MASA,OARAK,QAAW,SAAAE,GACPH,UAAYC,QAAYE,EAAZF,OAAZD,GACA,qBAAWA,EAAP,UACI,qBAAOA,EAAP,MAAiCA,UAAYA,EAAjD,QACIA,OAASA,EAATA,WAGTI,GAPHH,KAQOD,EAAP,MAeEM,EAA0B,SAACV,EAAD,OAC5B,IAAMC,EAAcD,mBAApB,EACME,EAAQC,WAAd,GACIQ,EAAJ,EACIC,EAAJ,EACQP,EAAiBL,EAAzB,MAAeM,EAAUN,EAAzB,MAKA,GAJAK,QAAW,SAAAE,GACPI,GAAON,QAAYE,EAAZF,OAAPM,GACAC,MACDJ,GAHHH,KAIA,IAAIO,EACJ,OAAOD,EAAP,GAGEE,EAAW,SAACb,EAAD,SACb,IAAMC,EAAcD,mBAApB,EACME,EAAQC,WAAd,GACQE,EAAiBL,EAAzB,MAAeM,EAAUN,EAAzB,MACAK,QAAW,SAAAE,GACPO,EAASP,EAAKF,QAAYE,EAAZF,OAAdS,MACDN,GAFHH,MAWEU,EAA2B,SAACf,EAAD,OAI7B,IAAMgB,EAAOhB,SAAb,GACIiB,EAAJ,EACIL,EAAJ,EAKA,GAJAZ,OAAYQ,GAAZR,GAAuB,cACnBiB,GAAW,KAAJ,IAAKC,EAAL,EAAPD,GACAL,OAEJ,IAAIA,EACJ,OAAOT,UAAUc,EAAjB,IAGJ,SAASE,EAAkBnB,EAA3B,KACI,OAAO,cACH,QADeQ,UAAS,GACpBA,EAAJ,EAAgB,MAAM,IAAIY,MAAV,2BAChB,OAAOC,EAAGrB,EAAOsB,EAASC,EAA1B,I,IAUaC,aAejB,c,WACIC,KAAA,MAAaH,EAAb,MACAG,KAAA,MAAaH,EAAb,MAEAG,KAAA,IAAWN,EAAkBM,KAAMH,EAAnC,GACAG,KAAA,IAAWN,EAAkBM,KAAMH,EAAnC,GACAG,KAAA,KAAYN,EAAkBM,KAAMH,EAApC,GACAG,KAAA,GA7BR,SAAiCzB,EAAjC,KACI,OAAO,gBACH,QADeQ,UAAS,GACpBA,EAAJ,EAAgB,MAAM,IAAIY,MAAV,2BAChB,OAAOC,EAAGrB,EAAOsB,EAASC,EAAGf,EAA7B,IA0BWkB,CAAwBD,KAAMH,EAAzC,GACAG,KAAA,MAAaN,EAAkBM,KAAMH,EAArC,GAEAG,KAAA,MAAa,YAET,QAFUjB,UAAS,GAEnB,IADoB,oCAApB,GAEA,OAAO,eAAuB,EAA9B,Q,SAUDmB,YAAP,cACI,OAAO,IAAIH,EAAM,CACblB,MADa,EAEbD,W,gCATR,WAEI,OADoBoB,KAAKpB,MAAMuB,4BAA/B,O,EAjCaJ,GCjGfK,aAqBF,gBAnBA,KAAA5C,IAAA,GACA,KAAA6C,KAAA,GAEA,KAAAC,MAAA,GACA,KAAAC,OAAA,EACA,KAAAC,QAAA,EAKA,KAAAC,eAAA,EAMA,KAAAC,eAAA,GACA,KAAAC,OAAA,GAGI,IAAMC,EAAY,CAAExC,UACpB4B,KAAA,UACAA,KAAA,MAAapC,kBAA0BoC,KAAKa,QAA5C,cACAb,KAAA,OAAc5B,EAAS,GAAvB,EACA4B,KAAA,cAAqBA,KAAKa,QAA1B,mBACAb,KAAA,e,2BAGJG,wCACI,OAAOzB,WAEHA,SAASsB,KAAKM,MAAd5B,OAA4BsB,KAAKQ,QAAjC9B,GAAgDA,SAFpD,K,EAcJoC,gBACI,YADA/B,UAAS,GACFiB,KAAKM,MAAMN,KAAKe,SAAvB,K,EAGJA,0BAAShC,UAAS,GACd,IAAIxB,EAAQyC,KAAKO,OAAjB,EACA,GAAIxB,EAAJ,EACI,OAAOxB,EAASyC,KAAKM,MAArB,OAEJ,KAAO/C,EAAP,GACIA,EAAQyC,KAAKM,MAAMlC,OAAnBb,EAEJ,U,EAGJyD,wBACI,IAAMC,EAAO,GAAH,OACHjB,KAAKa,QAAQK,OADV,WAEHlB,KAAKa,QAAQK,OAFpB,gBAKAlB,KAAA,kBACA,IAAMW,EAAN,GAEMQ,EAAN,KACAF,WAAa,SAAAzD,GACTmD,KAAc,WAIV,OAHKQ,iBAAL,KACIA,oBAAgCpB,gBAAhCoB,IAEGA,iBAAP,OAURnB,KAAA,OAAc,IAAIoB,MAAMT,EANF,CAClBG,IAAK,gBACD,OAAOO,EAAP,S,EAOZC,uBAEI,IAAMC,EAAcvB,KAAKwB,QAAQxB,KAAKa,QAAtC,SAIA,GAHAb,KAAA,kBAGA,IAAIA,KAAKwB,QAAQC,QAAe,CAC5B,IAAMC,EAAW1B,KAAKc,KAAtB,GACIY,EAAJ,SACI1B,KAAA,cAAmBA,KAAnB,WAIRA,KAAA,UACAA,KAAA,SACIA,KAAKO,SAAWP,KAAKM,MAAzB,SACIN,KAAA,UAGJ2B,cAAc3B,KAAKM,MAAMN,KAAzB2B,QAAuC3B,KAAKa,QAA5Cc,OAEA3B,KAAA,MAAWA,KAAX,QAAwBA,KAAKa,QAA7B,SAAgDU,EAAcvB,KAAKa,QAAnE,U,EAGJe,+BAKI,IAAIC,EAAJ,EAKA,GAJI7B,KAAKa,QAAT,uBACIgB,KAGA7B,KAAKa,QAAQiB,SAAW,GAAK9B,KAAjC,eAAsD,CAClD,IACM+B,GADUC,EAAOhC,KAAvB,gBACiCA,KAAKa,QAAfoB,SAAvB,EACA,GAAIF,EAAJ,EACI,IAAK,IAAIG,EAAT,EAAgBA,EAAhB,EAAkCA,IAAK,CACnC,IAAMnD,EAASiB,KAAKa,QAApB,SACMsB,EAAenC,KAAKS,eAA1B,EACAT,KAAA,iCACAA,KAAA,oB,EAUhBoC,oBAEI,IAAMC,EAAarC,KAAKa,QAAQyB,cAAcC,EAA9C,MAEAvC,KAAA,sBAEAA,KAAA,gBAAAA,KAA2BA,KAA3B,aAEIA,KAAKwC,cAAcxC,KAAnB,YAAmDA,KAAvD,kBACIA,KAAA,sBACAA,KAAA,mB,EASRyC,sBACI,IAAMC,EAAcV,GAAQO,EAAKvC,KAAKa,QAAtC,SACMwB,EAAarC,KAAKa,QAAQyB,cAAhC,GAEKtC,KAAL,iBACIA,KAAA,kBAGAA,KAAKa,QAAQiB,SAAW,GAAK9B,KAAKa,QAAtC,sBACIb,KAAA,sBAGJA,KAAA,gBAAAA,KAA2BA,KAA3B,aAEA,IAAIA,KAAKa,QAAQiB,WACb9B,KAAA,sBACAA,KAAA,kBAGJA,KAAA,UAAiBA,KAAjB,Y,EAGJ2C,0BAAiDlE,WAAS,GAYtD,IAXA,IAAMmE,EAAgBlE,SAASK,GAA/B,GACM8D,EAAgBpE,KAAaC,SAAbD,GAAtB,EACMqE,EAAgB9C,KAAKM,MAAMlC,OAAjC,EAEM2E,EAAwB,CAC1BxF,MAAOyC,KAAKO,OADc,EAE1ByC,SAF0B,EAG1BC,QAAS,GAGTC,EAAMlD,KAAKM,MAAf,OACO4C,OAECN,GAAcG,WAAlB,MAGItE,MAAcsE,WAAlB,IAKIA,QAAJ,IACIA,QAAY/C,KAAKM,MAAMlC,OAAvB2E,GAGJ1D,EAAS,EAELW,KAFJX,OAKA0D,YACAA,UACAA,c,EAIRI,wBAAiC1E,WAAS,GAYtC,IAXA,IAAM2E,EAASpD,KAAKM,MAApB,OACI+C,EAAM5E,OAAV,EAEMsE,EAAwB,CAC1BxF,MAD0B,EAE1ByF,WAAYI,EAFc,GAG1BH,QAAS,GAGTC,EAAJ,EAEOA,KAAOG,KACVN,SAAaK,EAASpD,KAAToD,OAAD,GAAZL,EAEA1D,EAAS,EAELW,KAFJX,OAKA0D,YACAA,c,uBA1MR,WACI,OAAO/C,KAAKM,MAAZ,S,mBAGJ,WACI,OAAON,KAAKM,MAAMN,KAAlB,Y,EA1CFI,GCEN,SAASkD,EAAWC,EAApB,KAEIA,eAGI/F,YAAJ,MAAsBA,MAClB+F,eACAA,sBAEAA,qBAGJ,oBAAWzF,EACPyF,UAEC,kBAAWzF,GACNA,EAAN,aACIyF,oBAEJA,QAAoBzF,EAApByF,GACAA,UAAsBzF,EAAtByF,MAGAA,QAAoB,qBAwB5B,SAASC,EAAU3D,EAAnB,GACI,IAAM0D,EAAuB,CACzBtC,KADyB,GAEzBwC,WAFyB,GAGzBC,WAHyB,GAIzBC,eAJyB,GAKzBC,OALyB,GAMzBC,WANyB,GAOzBjE,GAPyB,GAQzBkE,KAAM,IAaV,OAVIlG,cAAciC,EAAlB,QAhCJ,SAA4B0D,EAA5B,GACmB1D,EAAf,OACAqB,SAAe,SAAArC,GACX,iBACI,aACIyE,EAAWC,EAAW1E,GAAO,SAAAkF,GAAC,OAAIA,EAAJ,MAC9B,MACJ,QACIT,EAAWC,EAAW1E,EAAZ,KAAVyE,OAyBRU,CAAmBT,EAAnBS,GAnBR,SAAiCT,EAAjC,GACI5B,eAAe9B,EAAf8B,iBAAuC,Y,IAAEnE,OAAKM,OAC1CwF,EAAWC,EAAW/F,EAAtB8F,MAmBAW,CAAwBV,EAAxBU,GAGJC,WAAoB,YAChBX,sBAA8BY,EAA9BZ,SAGJ,EAGJ,SAASa,EAAoBlD,GACzB,IAAMmD,EAAS,CAAE5C,QAAS,GAO1B,OANAP,sBAA0B,SAAA1D,GACtB6G,eAEJnD,0BAA8B,SAAA1D,GAC1B6G,eAEG,2BAGX,IAAMC,EAAY,SAACxG,G,2BAAeyG,uDAC9B,0BAAWzG,EAA6BA,eAAP,GACjC,GAGJ,SAAgB0G,EAAc3E,GAE1B,IAAMqB,EAASsC,EAAU3D,EAAzB,IAEMgB,EAAmB,CACrB4D,cAmFJ,cACI,GAAI5D,iBAAJ,GAAkC,MAAM,IAAIlB,MAAM,0BAAV,EAAN,qBAClCkB,sBACAA,mBAAyB,CAAE6D,KAAF,EAAQC,eAjEjC9D,SAA0B2C,EAAU3D,EAASgB,EAA7CA,aACAA,eAA0BuD,EAAoBvD,EAA9CA,QACAA,cAA0BA,EAAA,oBAA2B,SAAA+D,GAAC,OAAI/D,oBAAJ,MACtDA,QA3HR,SAAoBgE,EAApB,GACI,IAAMC,EAAG,KAAT,GAEA,OADAC,WAAqB,SAAAvH,GAAG,cAAWsH,EAAX,MACxB,EAwH8BE,CAAWnE,EAAD,eAAyBA,EAA7DA,aAgEAA,kBAAuB,SAAAoE,GAAC,OAAIA,EAAJ,mBAvFxBC,MAFqB,GAGrBC,aAAwBtF,EAHH,aAIrBuF,QAkEJ,mBA5BA,gBACIC,YACAxE,6BAAkC,SAAArD,GAC9BqD,iBAA6BwE,EAA7BxE,SAEJA,6BAAkC,SAAArD,GAC9B,GAAIA,IAAQqD,EAAZ,QAA6B,CACzB,IACMwB,EAAaC,EADFN,GAAQO,EAAzB,IAEAA,OAEJ,IAAM+C,EAASzE,iBAA6BwE,EAA7BxE,GAAf,GACA,qBAAWyE,IACPD,YAgBRE,CAAgBF,EAAU9C,EAA1BgD,GAtCJ,cACI1E,uBAA4B,SAAAsD,GACxB,IAAMmB,EAASnB,aAAgBvF,EAA/B,QACA,qBAAW0G,IACPD,EAASlB,EAATkB,YAmCRG,CAAqBH,EAArBG,IAnEAC,aAAwBrB,EALH,GAMrBsB,YANqB,GAOrBC,eAPqB,GAQrBzB,YARqB,GASrB0B,MAmDJ,cACI/E,4BACY,SAAArD,GAAG,QAAMqD,cAAN,MADfA,SAEa,SAAArD,GACL6H,EAASxE,EAATwE,SAA4B3D,EAASb,EAATa,SAA4Bb,EAAxDwE,SACAA,KAAgBxE,iBAAhBwE,MAERA,aAzDAnE,OAVqB,EAWrBoB,cAXqB,EAYrBR,SAAwBjC,YAZH,EAarBgG,mBA8DJ,kBACI,IAAMxD,EAAaC,EAAnB,GAEA,2BAAW7B,IACX,IAAII,YACAwB,KAA+BxB,EAAnC,WAlEAF,OAdqB,GAerBmF,qBAAwBjG,EAfH,qBAgBrBkG,QAAwBzB,EAAUzE,EAAVyE,UAhBH,OAiBrB0B,UAAwBnG,aAjBH,GAkBrBoG,OAAwB,IAU5B,cACI,OAAIpF,EAAJ,SAA6BmB,EAAQA,EAAOnB,EAAtB,SACtB,EA8DJ,S,SCjMY/C,EAAMA,EAAYoI,GAC9B,MAAwB,qBAAVpI,EAAwBA,EAAtC,EAGJ,SAAgBqI,EAAKC,EAAoBtI,GACrC,KACI,0BAAWA,EACAA,IAEX,ECNR,IAAMuI,EAAW,qBAEXC,aAWJ,cAPA,KAAAL,OAAA,GACA,KAAAM,UAAA,EAOEvG,KAAA,QAAewE,EAAf,G,2BAGFC,4BACEzE,KAAA,4B,EAGFwG,sBACE,OAAO7E,OAAA,QAAe3B,KAAf,gBACG,SAAAyG,GAAE,OAAKC,GAAW,sBAAaD,EAAzB,GAAgCA,EAApC,OADL,KAEA,SAAAA,GAAE,OAAIA,EAAJ,O,EAGXE,yBACE,IAAI3G,KAAKa,QAAT,uBACIb,KAAJ,UAEA,IAAMmB,EAAN,KAGAnB,KAAA,MAAa4G,aACX,WACEzF,0BAAiC,YAC/B0F,yBAEE1F,EAAJ,YACEA,iBAEDnB,KAAKa,QARV,UAWAb,KAAA,c,EAGF8G,wBACEC,cAAc/G,KAAd+G,OACA/G,KAAA,a,EAGFoC,sBACEpC,KAAA,oBACA2B,eAAe3B,KAAf2B,gBACU,SAAA8E,GAAE,OAAKC,GAAD,GAAqBD,EAArB,GAA4BA,EAAhC,OADZ9E,SAEW,SAAA8E,GAAE,OAAIA,aAAJ,O,EAGfhE,sBACEzC,KAAA,oBACA2B,eAAe3B,KAAf2B,gBACU,SAAA8E,GAAE,OAAKC,GAAD,GAAqBD,EAArB,GAA4BA,EAAhC,OADZ9E,SAEW,SAAA8E,GAAE,OAAIA,aAAJ,O,EAGfO,6BACE,IACMnG,EAAUb,KAAhB,QACMiH,EAAmBpG,EAAA,eACvB,SAAAqG,GAAE,OAAIC,EAAe5E,EAAD,GAAlB,OADqB,KAAzB,KAGA,IALA,KAKKpB,OAAL,GAAiC,CAC7B,IAAMvC,EAAQ,IAAIwB,EAAoBS,EAAxB,aAAd,GACAA,qBAA0B,SAAAqG,GACxBtI,UAAiB2D,EAAjB3D,MAEFA,QAVJ,KAWIuC,YACAN,iBAZJ,KAaI,cAbJ,KAcMM,kB,EAhFJmF,GCHEc,EAAkB1I,KAA1B,IAAa2I,EAAa3I,KAA1B,IAAkB4I,EAAQ5I,KAA1B,IA0EA,EAAe,CACX6I,YAAa,CACTvF,KA1EK,CACTwF,WAAY,CADH,QAETtG,OAAQ,CACJc,KAAgB,qBAAalE,EAAM2J,EAAM1D,EAAzB,SAwEhB2D,KApEK,CACTF,WAAY,CADH,SAETtG,OAAQ,CACJyG,KAAgB,CAAE/H,GAAI,qBAAa9B,EAAM2J,EAAM1D,EAAzB,QAAmCD,KAAM,SAAA8D,GAAC,OAAIA,EAAJ,QAChEC,KAAgB,CAAEjI,GAAI,qBAAayH,EAAItD,EAAD,MAAUjG,EAAM2J,EAAM1D,EAAtC,SAAiDD,KAAM,SAAA8D,GAAC,OAAIA,EAAJ,QAC9EE,IAAgB,CAAElI,GAAI,qBAAawH,EAAIrD,EAAD,MAAUjG,EAAM2J,EAAM1D,EAAtC,SAAiDD,KAAM,SAAA8D,GAAC,OAAIA,EAAJ,QAC9EG,MAAgB,CAAEnI,GAAI,mBAAOmE,EAAP,OAAgBD,KAAM,SAAA8D,GAAC,OAAIA,EAAJ,UA+D7CI,KA3DK,CACTR,WAAY,CAAC,MADJ,QAETtG,OAAQ,CAMJ+G,KAAgB,mBAAO9B,EAAKpC,MAAD,GAAY,kBAAMA,MAAN,MACvCmE,MAAgB,mBAAO/B,EAAKpC,MAAD,GAAY,kBAAMA,OAAN,QAmDvCoE,OA9CO,CACXX,WAAY,CADD,OAEXtG,OAAQ,CAEJkH,OAAgB,CAAExI,GAAI,qBAAauG,EAAKpC,EAAD,IAAQjG,EAAM2J,EAAN3J,GAAiBiG,EAA1C,MAAkDD,KAAM,sBAC9EuE,QAAgB,CAAEzI,GAAI,qBAAauG,EAAKpC,EAAD,KAASjG,EAAM2J,EAAN3J,GAAiBiG,EAA3C,MAAmDD,KAAM,sBAC/EwE,OAAgB,CAAE1I,GAAI,qBAAa9B,EAAM2J,EAAN3J,GAAiBwJ,EAAIvD,EAAlC,MAA0CD,KAAM,sBACtEyE,OAAgB,CAAE3I,GAAI,qBAAa9B,EAAM2J,EAAN3J,GAAiBiG,EAA9B,KAAqCD,KAAM,sBACjE0E,UAAgB,CACI5I,GAAI,qBAAa9B,EAAM2J,EAAN3J,GAAiBiG,EAA9B,KACJF,YAAY,KAqChC4E,GA/BG,CACPjB,WAAY,CAAC,MAAD,6BADL,UAEPtG,OAAQ,CAEJwH,MAAgB,CAAE9I,GAAI,qBAAauG,EAAKpC,EAAD,IAAQjG,EAAM2J,EAAN3J,GAAiBiG,QAAUA,EAApD,MAA4DD,KAAM,sBACxF6E,OAAgB,CAAE/I,GAAI,qBAAauG,EAAKpC,EAAD,KAASjG,EAAM2J,EAAN3J,GAAiBiG,QAAUA,EAArD,MAA6DD,KAAM,sBACzF8E,MAAgB,CAAEhJ,GAAI,qBAAa9B,EAAM2J,EAAN3J,GAAiBiG,QAAUuD,EAAIvD,EAA5C,MAAoDD,KAAM,sBAChF+E,MAAgB,CAAEjJ,GAAI,qBAAa9B,EAAM2J,EAAN3J,GAAiBiG,QAAUA,EAAxC,KAA+CD,KAAM,sBAG3EgF,YAAgB,CAAElJ,GAAI,uBAAkBmJ,QAAYA,EAA9B,QAA0CjF,KAAM,wBAsBtEkF,MAlBM,CACVxB,WAAY,CAAC,MADH,QAEVtG,OAAQ,CAEJ+H,cAAgB,CAAErJ,GAAI,qBAAa9B,EAAM2J,EAAN3J,GAAb,GAAiCgG,KAAM,sBAC7DoF,cAAgB,CAAEtJ,GAAI,qBAAauG,EAAKpC,EAAD,IAAQjG,EAAM2J,EAAN3J,GAAzB,IAA8CgG,KAAM,sBAC1EqF,eAAgB,CAAEvJ,GAAI,qBAAauG,EAAKpC,EAAD,KAASjG,EAAM2J,EAAN3J,GAA1B,IAA+CgG,KAAM,0B,ICpE7EsF,EAAU,I,KAAIC,GAAW,EAAG,IAAM,IAAK,GAAI,IAE3CC,EAAS,IAAIC,EAAQ,CACzBzH,SAAgB,IAChBqD,aAAgB,GAChBa,UAAgB,CAAC,QACjB9E,OAAO,2EACFsI,EAAYjC,YAAYvF,KAAKd,QAC7BsI,EAAYjC,YAAYG,KAAKxG,QAC7BsI,EAAYjC,YAAYS,KAAK9G,QAC7BsI,EAAYjC,YAAYyB,MAAM9H,QAC9BsI,EAAYjC,YAAYY,OAAOjH,QAC/BsI,EAAYjC,YAAYkB,GAAGvH,UAIlCoI,EAAO7E,cAAc,SAAS,SAAC9D,GAC7B,OAAOA,EAAOoH,MAAMxI,KAAK,OAG3B+J,EAAO7E,cAAc,SAAS,SAAC9D,GAE7B,IACMnD,EAAG,aADC,IAGJiM,EAAQ9I,EAAOoH,MACf2B,EAAY/I,EAAOnD,GAEzB,KAAIkM,EAAUC,gBAAkB7J,IAAhC,CAIA,IAAI8J,EAAOF,EAAU5L,OAAO,GACvB8L,IACHA,EAAOH,EAAMlK,KAZL,IAYc,IAMxB,OAFYkK,EAAM3L,SADR,MACsB8L,GAAQ,EAD9B,UAMZN,EAAO7E,cAAc,SAAS,SAACoF,GAG7B,OAAIA,EAAEC,MAAMhM,MAAO,GAAK+L,EAAEE,MAAMjM,MAAO,IACnC+L,EAAEC,MAAMhM,OAAO,GAAK+L,EAAEE,MAAMjM,OAAO,GAC1B,EAIT+L,EAAEC,MAAMhM,MAAO,GAAK+L,EAAEE,MAAMjM,MAAO,IACnC+L,EAAEC,MAAMhM,OAAO,GAAK+L,EAAEE,MAAMjM,OAAO,IACzB,OAFd,KASF,IAAMkM,EAAU,CACdhI,KAAQ,EACRiI,KAAQ,UACRR,MAAQ,EACRS,IAAQ,GAUK,iBAEb,IAAMC,EAAIC,IAAMC,OAAO,CAAE9M,MAAO,EAAGyE,KAAM,EAAGsI,WAAY,EAAGC,QAAS,EAAGC,UAAW,EAAGC,aAAa,EAAOC,SAAS,IAASlJ,QAC3H,EAA8BmJ,mBAAmB,IAAjD,mBAAOC,EAAP,KAAgBC,EAAhB,KACA,EAAgCF,mBAAgB,IAAhD,mBAAOG,EAAP,KAAiBC,EAAjB,KAEMC,EAAgBZ,IAAMa,aAAY,SAACrM,GACvC,IAAIxB,EAAiB,GACf8N,EAAQ,IAAItN,MAAMgB,EAAMR,QAC9BQ,EAAMuE,MAAK,SAACJ,EAAKuG,GACf4B,EAAMnI,EAAIE,SAAWqG,EAAOvG,EAAIxF,OAChCH,EAAOuE,OAAOV,KAAKiK,EAAMnI,EAAIE,aAE/B4H,EAAWzN,GACX2N,EAAYG,KACX,IAGHC,qBAAU,WAER7B,EAAO8B,aAAe,SAACxM,GACrBA,EAAMyM,SAAW,WACfL,EAAcpM,KAIlB0K,EAAOgC,WAAa,WAClB,IAAM1M,EAAQ+C,OAAO4J,OAAOjC,EAAOrD,QAAQ,GAC3C+E,EAAcpM,IAKhB0K,EAAO3C,kBAEN,CAACqE,IAIJG,qBAAU,YACa,SAAfK,KA/CV,SAA4BxJ,GAC1BgI,EAAQhI,KAAQA,EAChBgI,EAAQP,MAAQL,EAAQqC,OACxBzB,EAAQE,IAAQxL,KAAKgN,MAAsB,IAAhBhN,KAAKiN,SAAiB,IACjDrC,EAAO7G,QAAQuH,GA4CX4B,EAAmB,IAAIC,MAAOC,WACzB3B,EAAEO,SACLqB,WAAWP,EAAc,GAG7BA,KACC,CAACrB,EAAEO,UAcN,IAAMsB,EAAcf,uBAAY,cAE7B,IAEH,OACE,oCACE,yBAAKpN,UAAU,4CAA4CoO,QAASD,GAClE,yBAAKnO,UAAU,eACb,yBAAKqO,MAAO,CAACC,aAAc,KAEvB,kBAACC,EAAD,CAAWhP,KAAMwN,EAAS3M,MAAO6M,SC9I/CuB,IAASC,OAAO,kBAACC,EAAD,MAASC,SAASC,eAAe,W","file":"static/js/main.146dac37.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Header = (props: any) => {\r\n    \r\n    const cols = props.cols || [];\r\n\r\n    return <thead>\r\n        <tr>\r\n            {\r\n                cols.map((c: any, index: number) => {\r\n                    return <th key={index}>{c}</th>\r\n                })\r\n            }\r\n        </tr>\r\n    </thead>\r\n}\r\n\r\nexport default Header;","import React from 'react';\r\n\r\nconst TableRow = (props: any) => {\r\n    \r\n    const item = props.item;\r\n    const cols = props.cols;\r\n\r\n    const isArray = Array.isArray(item);\r\n\r\n    return (\r\n        <tr className=\"no-text-overflow\">\r\n\r\n            {\r\n                isArray &&\r\n                item.map((value: any, index: number) => {\r\n                    return <td key={cols[index]}>\r\n                        {\r\n                            typeof value === 'number' &&\r\n                            value.toFixed(0)\r\n                        }\r\n                    </td>\r\n                })   \r\n            }\r\n\r\n            {\r\n                !isArray &&\r\n                cols.map((c: any, index: number) => {\r\n                    return <td key={cols[index]}>\r\n                        {\r\n                            typeof item[c] === 'number' &&\r\n                            item[c].toFixed(0)\r\n                        }\r\n                    </td>\r\n                })\r\n            }\r\n        </tr>\r\n    )\r\n}\r\n\r\nexport default TableRow;","import React from 'react'\r\nimport Header from './Header';\r\nimport TableRow from './TableRow';\r\nimport './style.css';\r\n\r\ntype Props = {\r\n    cols: string[],\r\n    items: any[],\r\n};\r\n\r\nconst Table = (props: Props) => {\r\n\r\n    const cols: string[] = props.cols;\r\n    const items = props.items;\r\n\r\n    if (!items) return null;\r\n\r\n    \r\n\r\n    return <table cellPadding={0} cellSpacing={0} className=\"data-table\" >\r\n        \r\n        {\r\n            cols && \r\n            cols.length > 0 &&\r\n            <Header cols={cols} />\r\n        }\r\n\r\n        <tbody>\r\n            {\r\n                items.map((item: any, itemIndex: number ) => (\r\n                    <TableRow key={itemIndex} item={item} cols={cols} />\r\n                ))\r\n            }\r\n        </tbody>\r\n    </table>\r\n    \r\n};\r\n\r\nexport default Table;\r\n","import ClosedCircuitBuffer from \"../ClosedCircuitBuffer\";\r\nimport { SerieOptions, AggregateFn1Def, AggregateFn1, CustomAggregateFnDef, CustomAggregateFn, CustomAggregateVoidCallback } from '../types';\r\n\r\nexport type CompetingValuePair = { current?: number, best?: number };\r\n\r\nconst fnMin: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const v: CompetingValuePair = {};\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        v.current = track.array[idx.index][field];\r\n        if (typeof v.current !== 'undefined') {\r\n            if (typeof v.best === 'undefined' || v.current < v.best) {\r\n                v.best = v.current;\r\n            }\r\n        }\r\n    }, offset||0, limit)\r\n    return v.best;\r\n}\r\n\r\nconst fnMax: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const v: CompetingValuePair = {};\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        v.current = track.array[idx.index][field];\r\n        if (typeof v.current !== 'undefined') {\r\n            if (typeof v.best === 'undefined' || v.current > v.best) {\r\n                v.best = v.current;\r\n            }\r\n        }\r\n    }, offset||0, limit);\r\n    return v.best;\r\n}\r\n\r\n\r\nconst fnSum: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    let sum = 0;\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        sum += track.array[idx.index][field];\r\n    }, offset||0, limit);\r\n    return sum;\r\n}\r\n\r\nconst fnMean: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    let sum = 0;\r\n    let cnt = 0;\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        sum += track.array[idx.index][field];\r\n        cnt++;\r\n    }, offset||0, limit);\r\n    if (cnt === 0) return undefined;\r\n    return sum / cnt;\r\n}\r\n\r\nconst fnCustom = (serie: Serie, options: SerieOptions, n: number, offset: number, callback: CustomAggregateVoidCallback) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const { track, field } = serie;\r\n    track.lifo(idx => {\r\n        callback(idx, track.array[idx.index][field])\r\n    }, offset||0, limit);\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Uses Bessel's correction of bias.\r\n * @param {array} array \r\n */\r\n \r\nconst fnStDev: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset?: number) => {\r\n    const availLength = serie.availableLength||0;\r\n    const limit = Math.min(availLength, n);\r\n    const { track, field } = serie;\r\n    const mean = serie.mean(n, offset)!;\r\n    let sumOfSq = 0;\r\n    let cnt = 0;\r\n    serie.fn(n, offset||0, (pos, val) => {\r\n        sumOfSq += (val - mean) ** 2;\r\n        cnt++;\r\n    });\r\n    if (cnt === 0) return undefined;\r\n    return Math.sqrt(sumOfSq / cnt);\r\n}\r\n\r\nfunction attachAggregateFn(serie: Serie, options: SerieOptions, fn: AggregateFn1Def) {\r\n    return (n: number, offset = 0) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset);\r\n    };\r\n}\r\nfunction attachCustomAggregateFn(serie: Serie, options: SerieOptions, fn: CustomAggregateFnDef) {\r\n    return (n: number, offset = 0, callback: CustomAggregateVoidCallback) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset, callback);\r\n    };\r\n}\r\n\r\nexport default class Serie {\r\n    \r\n    fn:  CustomAggregateFn;\r\n    min: AggregateFn1;\r\n    max: AggregateFn1;\r\n\r\n    mean: AggregateFn1;\r\n    \r\n    stDev: AggregateFn1;\r\n\r\n    value: (offset?: number) => number | undefined;\r\n\r\n    track: ClosedCircuitBuffer;\r\n    field: string;\r\n\r\n    constructor(options: SerieOptions) {\r\n        this.track = options.track;\r\n        this.field = options.field;\r\n\r\n        this.min = attachAggregateFn(this, options, fnMin);\r\n        this.max = attachAggregateFn(this, options, fnMax);\r\n        this.mean = attachAggregateFn(this, options, fnMean);\r\n        this.fn  = attachCustomAggregateFn(this, options, fnCustom);\r\n        this.stDev = attachAggregateFn(this, options, fnStDev);\r\n\r\n        this.value = (offset = 0) => {\r\n            const availLength = this.track.getOffsetAdjAvailableLength(offset);\r\n            if (availLength === 0) return undefined;\r\n            return this.track.get(offset)[this.field];\r\n        }\r\n    }\r\n\r\n    get availableLength() {\r\n        const availLength = this.track.getOffsetAdjAvailableLength(0);\r\n        return availLength;\r\n    }\r\n    \r\n\r\n    static createSerie(field: string, track: ClosedCircuitBuffer) {\r\n        return new Serie({\r\n            field,\r\n            track,\r\n        });\r\n    }\r\n}","import Serie from './Serie';\r\nimport {\r\n    IteratorCallback,\r\n    IteratorPosition,\r\n    NewSamplePredicate,\r\n    Sampler,\r\n    Dictionary,\r\n} from './types';\r\n\r\nclass ClosedCircuitBuffer {\r\n    \r\n    key: string = '';\r\n    tags: any = {};\r\n\r\n    array: any[] = [];\r\n    cursor: number = 0;\r\n    counter = 0;\r\n\r\n    shouldAdvance: NewSamplePredicate;\r\n\r\n    // prevSample: any;\r\n    lastPeriodTime: number = 0;\r\n    sampler: Sampler;\r\n\r\n    onUpdate?: () => void;\r\n    lastAdvanceTime?: number;\r\n\r\n    serieInstances: any = {};\r\n    series: Dictionary<Serie> = {};\r\n\r\n    constructor(length: number, sampler: Sampler) {\r\n        const arrayLike = { length }; \r\n        this.sampler = sampler!;\r\n        this.array = Array.from(arrayLike).map(this.sampler.createSample);\r\n        this.cursor = length ? 0 : -1;\r\n        this.shouldAdvance = this.sampler.newSamplePredicate;\r\n        this.createSeries();\r\n    }\r\n    \r\n    getOffsetAdjAvailableLength(offset: number) {\r\n        return Math.max(\r\n            0,\r\n            Math.min(this.array.length, this.counter + 1) - Math.abs(offset)\r\n        );\r\n    }\r\n\r\n    get length() {\r\n        return this.array.length;\r\n    }\r\n\r\n    get current() {\r\n        return this.array[this.cursor];\r\n    }\r\n\r\n    get(offset = 0) {\r\n        return this.array[this.getIndex(offset)];\r\n    }\r\n\r\n    getIndex(offset = 0) {\r\n        let index = this.cursor + offset\r\n        if (offset > 0) {\r\n            return index  % this.array.length;\r\n        }\r\n        while (index < 0) {\r\n            index = this.array.length + index;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    createSeries() {\r\n        const keys = [\r\n            ...this.sampler.fields.publicKeys,\r\n            ...this.sampler.fields.expressionKeys,\r\n        ];\r\n\r\n        this.serieInstances = {};\r\n        const series = {};\r\n\r\n        const _instance = this;\r\n        keys.forEach(key => {\r\n            series[key] = () => {\r\n                if (!_instance.serieInstances[key]) {\r\n                    _instance.serieInstances[key] = Serie.createSerie(key, _instance);\r\n                }\r\n                return _instance.serieInstances[key];\r\n            }\r\n        })\r\n\r\n        const seriesHandler = {\r\n            get: (target, prop, receiver) => {\r\n                return target[prop]();\r\n            }\r\n        };\r\n        \r\n        this.series = new Proxy(series, seriesHandler);\r\n    }\r\n    \r\n    nextSample(caller: string) {\r\n        \r\n        const currentTime = this.current[this.sampler.timeKey];\r\n        this.lastAdvanceTime = currentTime;\r\n\r\n        // see if the current slot hasn't received any data and fill forward from last slot\r\n        if (this.current.__count === 0) {    \r\n            const prevSlot = this.get(-1);\r\n            if (prevSlot.__count) {\r\n                this.sampler.ffill(this.current, prevSlot);                          \r\n            }\r\n        }  \r\n\r\n        this.counter++;\r\n        this.cursor++;\r\n        if (this.cursor === this.array.length) {\r\n            this.cursor = 0;\r\n        }\r\n        \r\n        Object.assign(this.array[this.cursor], this.sampler.blank);\r\n\r\n        this.array[this.cursor][this.sampler.timeKey] = currentTime + this.sampler.interval;\r\n    };\r\n\r\n    fillMissingSamples(time: number) {\r\n        // when loading from history, we need to account for missing data\r\n        // and insert missing samples, something that would normally\r\n        // be taken care of by the timer\r\n\r\n        let normallySkippedMax = 1;\r\n        if (this.sampler.suppressAutoSampling) {\r\n            normallySkippedMax = 0;\r\n        }\r\n\r\n        if (this.sampler.interval > 0 && this.lastPeriodTime) {\r\n            const elapsed = time - this.lastPeriodTime;\r\n            const missingSamples = elapsed / this.sampler.interval - normallySkippedMax;\r\n            if (missingSamples > 0) {\r\n                for (let i = 0; i<missingSamples; i++) {\r\n                    const offset = this.sampler.interval;\r\n                    const insertedTime = this.lastPeriodTime + offset;\r\n                    this.nextSample('fillMissingSamples');\r\n                    this.lastPeriodTime = insertedTime;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Preload buffer with history data\r\n     * @param data \r\n     */\r\n    preload(data: any) {\r\n\r\n        const sampleTime = this.sampler.getSampleTime(data.time);\r\n        \r\n        this.fillMissingSamples(sampleTime)\r\n\r\n        this.sampler.collect(this, this.current, data, sampleTime);\r\n        \r\n        if (this.shouldAdvance(this.current, data, sampleTime, this.lastPeriodTime)) {\r\n            this.nextSample('preload'); \r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Record real-time data from a stream\r\n     * @param data \r\n     * @returns \r\n     */\r\n    capture(data: any, time?: number) {\r\n        const captureTime = time || data[this.sampler.timeKey];\r\n        const sampleTime = this.sampler.getSampleTime(captureTime);\r\n\r\n        if (!this.lastPeriodTime) {\r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n        // if any samples were skipped, fill them before capturing\r\n        if (this.sampler.interval > 0 && this.sampler.suppressAutoSampling) {\r\n            this.fillMissingSamples(sampleTime);\r\n        }\r\n\r\n        this.sampler.collect(this, this.current, data, sampleTime);\r\n\r\n        if (this.sampler.interval === 0) {\r\n            this.nextSample('capture'); \r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n        \r\n        this.onUpdate && this.onUpdate();\r\n    }\r\n    \r\n    lifo(callback: IteratorCallback, offset: number, limit = -1) {\r\n        const absOffset     = Math.abs(offset || 0);\r\n        const requestedLmt  = limit >= 0 ? Math.abs(limit) : 0;\r\n        const offsetAdjLmt  = this.array.length - absOffset;\r\n        \r\n        const pos: IteratorPosition = {\r\n            index: this.cursor - absOffset, // starting position (adjusted for offset)\r\n            relative: 0,                    \r\n            ordinal: 0,                     // zero based iteration number\r\n        };\r\n\r\n        let j   = this.array.length;\r\n        while (j--) {\r\n\r\n            if (absOffset  && pos.ordinal >= offsetAdjLmt) {\r\n                break;\r\n            }\r\n            if (limit >= 0 && pos.ordinal >= requestedLmt) {\r\n                break;\r\n            }\r\n\r\n            // loop around\r\n            if (pos.index < 0) {\r\n                pos.index = this.array.length - 1; \r\n            }\r\n\r\n            callback(\r\n                pos,\r\n                this.array\r\n            );\r\n\r\n            pos.ordinal++;\r\n            pos.index--;\r\n            pos.relative--;\r\n        }\r\n    }\r\n\r\n    fifo(callback: IteratorCallback, limit = -1) {\r\n        const arrlen = this.array.length;\r\n        let lmt = limit >= 0 ? limit : arrlen;\r\n\r\n        const pos: IteratorPosition = {\r\n            index: 0,                   \r\n            relative: -(arrlen - 1),                    \r\n            ordinal: 0,                 \r\n        };\r\n\r\n        let j = arrlen;\r\n        let i = 0;\r\n        while (j-- && lmt--) {\r\n            pos.index = (arrlen + this.cursor - j) % arrlen;\r\n\r\n            callback(\r\n                pos,\r\n                this.array\r\n            );\r\n\r\n            pos.ordinal++;\r\n            pos.relative++;\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n}\r\n\r\nexport default ClosedCircuitBuffer;","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\n\r\nimport Serie from \"./Serie\";\r\nimport { Sampler, SamplerOptions, FieldDict, Expression, SampleFieldDictEntry, SampleFieldArrayItem } from \"./types\";\r\n\r\nfunction deleteKeys(object: any, keysToDelete: string[]) {\r\n    const obj: any = {...object};\r\n    keysToDelete.forEach(key => delete obj[key]);\r\n    return obj;\r\n}\r\n\r\nfunction parseField(fieldDict: FieldDict, key: string, value: any) {\r\n\r\n    fieldDict.keys.push(key);\r\n    \r\n    // hidden\r\n    if (key[0] === '_' && key[1] !== '_') {\r\n        fieldDict.hidden[key] = true;\r\n        fieldDict.hiddenKeys.push(key);\r\n    } else {\r\n        fieldDict.publicKeys.push(key);\r\n    }\r\n\r\n    if (typeof value === 'function') {\r\n        fieldDict.fn[key] = value;\r\n    } \r\n    else if (typeof value === 'object') {\r\n        if (!!value.cumulative) {\r\n            fieldDict.cumulative[key] = true;\r\n        }\r\n        fieldDict.fn[key] = value.fn;\r\n        fieldDict.fill[key] = value.fill;\r\n    } \r\n    else { // number\r\n        fieldDict.fn[key] = () => value;\r\n    }\r\n}\r\n\r\nfunction parseFieldsAsArray(fieldDict: FieldDict, options: SamplerOptions) {\r\n    const fields = options.fields as SampleFieldArrayItem[];\r\n    fields.forEach(field => {\r\n        switch (typeof field) {\r\n            case 'string':\r\n                parseField(fieldDict, field, d => d[field] )\r\n                break;\r\n            default: // must be of type SampleFieldNamed\r\n                parseField(fieldDict, field.name, field)\r\n                break;\r\n        }\r\n    });\r\n}\r\n\r\nfunction parseFieldsAsDictionary(fieldDict: FieldDict, options: SamplerOptions) {\r\n    Object.entries(options.fields).forEach(([key, value]) => {\r\n        parseField(fieldDict, key, value);\r\n    });\r\n}\r\n\r\nfunction getFields(options: SamplerOptions, expressions: any[]) {\r\n    const fieldDict: FieldDict = {\r\n        keys: [],\r\n        publicKeys: [],\r\n        hiddenKeys: [],\r\n        expressionKeys: [],\r\n        hidden: {},\r\n        cumulative: {},\r\n        fn: {},\r\n        fill: {},\r\n    };\r\n\r\n    if (Array.isArray(options.fields)) {\r\n        parseFieldsAsArray(fieldDict, options);\r\n    } else {\r\n        parseFieldsAsDictionary(fieldDict, options);\r\n    }\r\n\r\n    expressions.forEach((expr: any) => {\r\n        fieldDict.expressionKeys.push(expr.name);\r\n    });\r\n\r\n    return fieldDict;\r\n}\r\n\r\nfunction createSampleFactory(fields: FieldDict) {\r\n    const sample = { __count: 0 };\r\n    fields.publicKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    fields.expressionKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    return () => ({ ...sample });\r\n}\r\n\r\nconst fnOrValue = (value: any, ...params: any[]) => {\r\n    if (typeof value === 'function') return value(...params);\r\n    return value;\r\n}\r\n\r\nexport function createSampler(options: SamplerOptions) {\r\n\r\n    const fields = getFields(options, []);\r\n\r\n    const sampler: Sampler = {\r\n        addExpression,          // hoisted funciton\r\n        blank:                  {},\r\n        bufferLength:           options.bufferLength,\r\n        collect,                // hoisted funciton\r\n        createSample:           createSampleFactory(fields),\r\n        cumulatives:            [],\r\n        expressionDict:         {},\r\n        expressions:            [],\r\n        ffill,                  // hoisted funciton\r\n        fields,\r\n        getSampleTime,          // hoisted funciton\r\n        interval:               options.interval || 0,\r\n        newSamplePredicate,     // hoisted funciton\r\n        series:                 {},\r\n        suppressAutoSampling:   options.suppressAutoSampling,\r\n        timeKey:                fnOrValue(options.timeKey)  || 'time',\r\n        trackKeys:              options.trackKeys || [],\r\n        tracks:                 [],\r\n    };\r\n\r\n    const initSeries = () => {\r\n        sampler.fields          = getFields(options, sampler.expressions);\r\n        sampler.createSample    = createSampleFactory(sampler.fields);\r\n        sampler.cumulatives     = sampler.fields.keys.filter(k => sampler.fields.cumulative[k]);\r\n        sampler.blank           = deleteKeys(sampler.createSample(), sampler.cumulatives);\r\n    }\r\n\r\n    function getSampleTime(time: number) {\r\n        if (sampler.interval) return time - (time % sampler.interval); \r\n        return time;\r\n    }\r\n\r\n    function calculateExpressions(currSlot: any, track: ClosedCircuitBuffer) {\r\n        sampler.expressions.forEach(expr => {\r\n            const result = expr.expression(track.series);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[expr.name] = result;\r\n            }\r\n        })\r\n    }\r\n\r\n    function aggregateSample(currSlot: any, data: any, time: number) {\r\n        currSlot.__count++;\r\n        sampler.fields.hiddenKeys.forEach(key => {\r\n            sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n        });\r\n        sampler.fields.publicKeys.forEach(key => {\r\n            if (key === sampler.timeKey) {\r\n                const origTime = time || data[key];\r\n                const sampleTime = getSampleTime(origTime);\r\n                data[key] = sampleTime\r\n            }\r\n            const result = sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[key] = result;\r\n            }\r\n        });\r\n    }\r\n\r\n    function ffill(currSlot: any, prevSlot: any) {\r\n        sampler.fields.publicKeys\r\n            .filter(key => !!sampler.fields.fill[key])\r\n            .forEach(key => {\r\n                currSlot[sampler.timeKey] = prevSlot[sampler.timeKey] + sampler.interval;\r\n                currSlot[key] = sampler.fields.fill[key](prevSlot);\r\n            });\r\n        currSlot.__count = 1;\r\n    };\r\n\r\n    function collect(track: ClosedCircuitBuffer, currSlot: any, data: any, time: number) {     \r\n        aggregateSample(currSlot, data, time);\r\n        calculateExpressions(currSlot, track);\r\n    };\r\n    \r\n    function newSamplePredicate(currSlot: any, data: any, time: number, lastPeriodTime: number) {\r\n        const sampleTime = getSampleTime(time);\r\n        // compare elapsed time since last period time\r\n        if (typeof lastPeriodTime === 'undefined') return true;\r\n        if (sampler.interval === 0) return true;\r\n        if (sampleTime - lastPeriodTime >= sampler.interval) return true; \r\n        return false;\r\n    };\r\n    \r\n    function addExpression(name: string, expression: Expression) {\r\n        if (sampler.expressionDict[name]) throw new Error(`A field with the name '${name}' already exists.`)\r\n        sampler.expressionDict[name] = expression;\r\n        sampler.expressions.push({ name, expression });\r\n        initSeries();\r\n        sampler.tracks.forEach(t => t.createSeries());\r\n    }\r\n\r\n    return sampler;\r\n}\r\n\r\n\r\n    \r\n","import { ConditionalOp } from \"./types\";\r\n\r\nexport function value(value: any, defaultValue: any) {\r\n    return typeof value !== 'undefined' ? value : defaultValue;\r\n}\r\n\r\nexport function when(condition: boolean, value: number | undefined | ConditionalOp) {\r\n    if (condition) {\r\n        if (typeof value === 'function') {\r\n            return value();\r\n        }\r\n        return value;\r\n    }\r\n    return undefined;\r\n}\r\n","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\nimport { BufferFilter, Expression, Sampler, SamplerOptions, Dictionary } from './types';\r\nimport { createSampler } from './createSampler';\r\nimport { value as valueOrDefault } from './helpers';\r\n\r\nconst noFilter = () => true;\r\n\r\nclass MultiTrackBuffer {  \r\n\r\n  timer:          any;\r\n  sampler:        Sampler;\r\n  tracks:         Dictionary<ClosedCircuitBuffer> = {};\r\n  sampling:       boolean         = false;\r\n  \r\n  // -- EVENTS \r\n  onTrackStart?:  (track: ClosedCircuitBuffer) => void;\r\n  onInterval?:    () => void;\r\n  \r\n  constructor(options: SamplerOptions) {\r\n    this.sampler = createSampler(options);\r\n  }\r\n\r\n  addExpression(name: string, expression: Expression) {\r\n    this.sampler.addExpression(name, expression);\r\n  }\r\n\r\n  getTracks(filter?: BufferFilter) {\r\n    return Object.entries(this.tracks)\r\n      .filter(kv => (filter || (() => true))(kv[0], kv[1]))\r\n      .map(kv => kv[1]);\r\n  }\r\n  \r\n  startSampling() {\r\n    if (this.sampler.suppressAutoSampling) return;\r\n    if (this.sampling) return;\r\n    \r\n    const _instance = this;\r\n\r\n    // timer for buffer group\r\n    this.timer = setInterval(\r\n      () => {\r\n        _instance.sampler.tracks.forEach((_track) => {\r\n          _track.nextSample('timer')\r\n        })\r\n        if (_instance.onInterval) {\r\n          _instance.onInterval();\r\n        }\r\n      }, this.sampler.interval\r\n    );\r\n\r\n    this.sampling = true;\r\n  }\r\n\r\n  stopSampling() {\r\n    clearInterval(this.timer);\r\n    this.sampling = false;\r\n  }\r\n\r\n  preload(data: any, filter?: BufferFilter) {\r\n    this.createDataTracks(data);\r\n    Object.entries(this.tracks)\r\n      .filter(kv => (filter || noFilter)(kv[0], kv[1]))\r\n      .forEach(kv => kv[1].preload(data));\r\n  }\r\n\r\n  capture(data: any, filter?: BufferFilter) {\r\n    this.createDataTracks(data);\r\n    Object.entries(this.tracks)\r\n      .filter(kv => (filter || noFilter)(kv[0], kv[1]))\r\n      .forEach(kv => kv[1].capture(data));\r\n  }\r\n\r\n  createDataTracks(data: any) {\r\n    const _instance = this;\r\n    const sampler = this.sampler;\r\n    const trackKey: string = sampler.trackKeys.map(\r\n      pk => valueOrDefault(data[pk], '')\r\n    ).join('.');\r\n    if (!_instance.tracks[trackKey]) {\r\n        const track = new ClosedCircuitBuffer(sampler.bufferLength, sampler);\r\n        sampler.trackKeys.forEach(pk => {\r\n          track.tags[pk] = data[pk];\r\n        })\r\n        track.key = trackKey;\r\n        _instance.tracks[trackKey] = track;\r\n        sampler.tracks.push(track);\r\n        if (_instance.onTrackStart) {\r\n          _instance.onTrackStart(track);\r\n        }\r\n        \r\n    }\r\n  }\r\n}\r\n\r\nexport default MultiTrackBuffer;\r\n","\r\nimport { value, when } from './helpers';\r\nimport { SampleFields } from './types';\r\n\r\nconst { min, max, abs } = Math;\r\n\r\nconst time = {\r\n    dataFields: [ 'time' ],\r\n    fields: {\r\n        time:           (d, curr) => value(curr, d.time), \r\n    } as SampleFields,\r\n};\r\n\r\nconst ohlc = {\r\n    dataFields: [ 'price'],\r\n    fields: {\r\n        open:           { fn: (d, curr) => value(curr, d.price), fill: p => p.close }, \r\n        high:           { fn: (d, curr) => max(d.price, value(curr, d.price)), fill: p => p.close }, \r\n        low:            { fn: (d, curr) => min(d.price, value(curr, d.price)), fill: p => p.close },\r\n        close:          { fn: (d) => d.price, fill: p => p.close },\r\n    } as SampleFields,\r\n};\r\n\r\nconst side = {\r\n    dataFields: [ 'buy', 'sell' ],\r\n    fields: {\r\n        // Underscore fields are special:\r\n        // - they are run first\r\n        // - they do not get added to sample (hidden)\r\n        // - they perform some operation \r\n        //   e.g. here they set a value on the data object itself\r\n        _buy:           (d) => when(d.qty > 0, () => d.buy  = 1),\r\n        _sell:          (d) => when(d.qty < 0, () => d.sell = 1),\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nconst volume = {\r\n    dataFields: [ 'qty' ],\r\n    fields: {\r\n        // volume\r\n        buyVol:         { fn: (d, curr) => when(d.buy, value(curr, 0) + d.qty), fill: () => 0 },\r\n        sellVol:        { fn: (d, curr) => when(d.sell, value(curr, 0) + d.qty), fill: () => 0 },\r\n        ttlVol:         { fn: (d, curr) => value(curr, 0) + abs(d.qty), fill: () => 0 },\r\n        netVol:         { fn: (d, curr) => value(curr, 0) + d.qty, fill: () => 0 },\r\n        cumNetVol:      { \r\n                            fn: (d, curr) => value(curr, 0) + d.qty, \r\n                            cumulative: true \r\n                        },\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nconst mv = {\r\n    dataFields: [ 'buy', 'sell', 'price', 'qty', 'ttlMv', 'ttlVol' ],\r\n    fields: {\r\n        // mv\r\n        buyMv:          { fn: (d, curr) => when(d.buy, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n        sellMv:         { fn: (d, curr) => when(d.sell, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n        ttlMv:          { fn: (d, curr) => value(curr, 0) + d.price * abs(d.qty), fill: () => 0 },\r\n        netMv:          { fn: (d, curr) => value(curr, 0) + d.price * d.qty, fill: () => 0 },\r\n\r\n        // volume weighted\r\n        volWtdPrice:    { fn: (d, curr, acc) => acc.ttlMv / acc.ttlVol, fill: () => 0 },\r\n    } as SampleFields,\r\n};\r\n\r\nconst stats = {\r\n    dataFields: [ 'buy', 'sell' ],\r\n    fields: {\r\n        // counts\r\n        ttlTradeCount:  { fn: (d, curr) => value(curr, 0) + 1, fill: () => 0 },\r\n        buyTradeCount:  { fn: (d, curr) => when(d.buy, value(curr, 0) + 1), fill: () => 0 },\r\n        sellTradeCount: { fn: (d, curr) => when(d.sell, value(curr, 0) + 1), fill: () => 0 },\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nexport default {\r\n    cryptoTrade: {\r\n        time,\r\n        ohlc,    \r\n        side,\r\n        volume,\r\n        mv,\r\n        stats,\r\n    },\r\n};\r\n\r\n    \r\n","import React, { useCallback, useEffect, useState } from \"react\";\r\nimport DataTable from './DataTable';\r\nimport Sampler, { ClosedCircuitBuffer, FieldGroups } from \"sample-gator\";\r\nimport RandomWalk from '@reactiff/random-walk';\r\n\r\nconst rndWalk = new RandomWalk(1, 1000, 500, 10, 10);\r\n\r\nconst buffer = new Sampler({\r\n  interval:       1000,               // in milliseconds\r\n  bufferLength:   30,                 // total samples in closed circuit buffer\r\n  trackKeys:      ['exch'],           // create track for each unique combination of these data fields\r\n  fields:         {\r\n    ...FieldGroups.cryptoTrade.time.fields,\r\n    ...FieldGroups.cryptoTrade.ohlc.fields,\r\n    ...FieldGroups.cryptoTrade.side.fields,\r\n    ...FieldGroups.cryptoTrade.stats.fields,\r\n    ...FieldGroups.cryptoTrade.volume.fields,\r\n    ...FieldGroups.cryptoTrade.mv.fields,\r\n  },\r\n});\r\n\r\nbuffer.addExpression('sma10', (series: any) => {\r\n  return series.close.mean(10)\r\n})\r\n\r\nbuffer.addExpression('ema10', (series: any) => {\r\n  \r\n  const n = 10;\r\n  const key = `ema${n}`;\r\n  \r\n  const price = series.close;\r\n  const calcSerie = series[key];\r\n  \r\n  if (calcSerie.availableLength < n + 1) {\r\n    return undefined;\r\n  }\r\n\r\n  let prev = calcSerie.value(-1);\r\n  if (!prev) {\r\n    prev = price.mean(n, -1);\r\n  }\r\n\r\n  const k = 2 / (n + 1);\r\n  const ema = price.value() * k + prev * (1 - k);\r\n\r\n  return ema;\r\n})\r\n\r\nbuffer.addExpression('cross', (_: any) => {\r\n\r\n  // check cross to the up side\r\n  if (_.ema10.value( 0) > _.sma10.value( 0) &&\r\n      _.ema10.value(-1) < _.sma10.value(-1)) {\r\n        return 1;\r\n  }\r\n\r\n  // check cross to the down side\r\n  if (_.ema10.value( 0) < _.sma10.value( 0) &&\r\n      _.ema10.value(-1) > _.sma10.value(-1)) {\r\n        return -1;\r\n  }\r\n  \r\n  return undefined;\r\n});\r\n\r\n// data capsule\r\nconst capsule = {\r\n  time:   0,\r\n  exch:   'RNDWALK',\r\n  price:  0,\r\n  qty:    0,\r\n};\r\n\r\nfunction simulateTradeEvent(time: number) {\r\n  capsule.time  = time;\r\n  capsule.price = rndWalk.next();\r\n  capsule.qty   = Math.round(Math.random() * 100 - 50);\r\n  buffer.capture(capsule);\r\n}\r\n\r\nexport default () => {\r\n\r\n  const m = React.useRef({ index: 0, time: 0, clickIndex: 0, periods: 5, tickCount: 0, initialized: false, stopped: false }).current;\r\n  const [columns, setColumns] = useState<string[]>([]);\r\n  const [fifoData, setFifoData] = useState<any[]>([]);\r\n\r\n  const readTrackData = React.useCallback((track: ClosedCircuitBuffer) => {\r\n    let cols: string[] = [];\r\n    const fifos = new Array(track.length);\r\n    track.fifo((pos, buffer) => {\r\n      fifos[pos.ordinal] = buffer[pos.index];\r\n      cols = Object.keys(fifos[pos.ordinal]);\r\n    });\r\n    setColumns(cols);\r\n    setFifoData(fifos);\r\n  }, []);\r\n\r\n\r\n  useEffect(() => {\r\n    \r\n    buffer.onTrackStart = (track) => {\r\n      track.onUpdate = () => {\r\n        readTrackData(track);\r\n      }\r\n    };\r\n\r\n    buffer.onInterval = () => {\r\n      const track = Object.values(buffer.tracks)[0];\r\n      readTrackData(track);\r\n    }\r\n\r\n    \r\n\r\n    buffer.startSampling();\r\n\r\n  }, [readTrackData]);\r\n\r\n\r\n  // simulate trade events\r\n  useEffect(() => {\r\n    const delayCapture = () => {\r\n      simulateTradeEvent(new Date().getTime());\r\n      if (!m.stopped) {\r\n        setTimeout(delayCapture, 0);\r\n      }\r\n    };\r\n    delayCapture();\r\n  }, [m.stopped]);\r\n\r\n  // read data\r\n  // useEffect(() => {\r\n  //   for (let i = 0; i < data.items.length; i++) {\r\n  //     const trade = {\r\n  //       time:   data.items[i][0],\r\n  //       price:  data.items[i][2],\r\n  //       vema10: data.items[i][4],\r\n  //     };\r\n  //     buffer.capture(trade);\r\n  //   }\r\n  // }, []);\r\n\r\n  const handleClick = useCallback(() => {\r\n    \r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <div className=\"flex row justify-center align-center fill\" onClick={handleClick}>\r\n        <div className=\"flex column\"> \r\n          <div style={{marginBottom: 15}}>\r\n            {\r\n              <DataTable cols={columns} items={fifoData} />\r\n            }\r\n          </div>\r\n        </div>\r\n      </div>\r\n  </>\r\n  )\r\n};\r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\nimport './css/index.css'\r\nimport './css/orthogonal.css'\r\nimport './css/flex.css'\r\n\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n"],"sourceRoot":""}